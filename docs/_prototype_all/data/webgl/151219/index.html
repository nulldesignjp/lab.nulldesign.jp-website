<!doctype html>
<html lang="ja-JP">
<head>
<title>webgl</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="keywords" content="">
<meta name="description" content="">
<style>
html,body{overflow:hidden;margin:0;padding:0;background:#FFF;}
canvas{position:fixed;left:50%;top:50%;margin-top:-256px;margin-left:-256px;box-shadow:0 0 16px rgba(0,0,0,0.4);}</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script type="x-shader/x-vertex" id="vertexshader">
attribute vec3 position;
uniform mat4 mvpMatrix;
void main()
{
	//	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );¥
	gl_PointSize = 3.0;
	gl_Position = mvpMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
precision mediump float;
void main()
{
	gl_FragColor = vec4( 0.1, 0.6, 0.9, 1.0 );
}
</script>
<script type="text/javascript" src="minMatrix.js"></script>
<script type="text/javascript">
(function(){
	var count = 0;
	var canvas = document.getElementById('canvas');
	canvas.width = 512;
	canvas.height = 512;

	var context = canvas.getContext('webgl');
	if( !context )
	{
		alert('webgl not supported!');
		return;
	}

	//	変数glにWebGLコンテキストを代入。
	var gl = context;

	//	クリア
	gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
	gl.clear( gl.COLOR_BUFFER_BIT );

	//	三角形を形成する頂点のデータを受け取る
	var triangleData = genTriangle();

	triangleData = sphere(16,16,0.5);

	//	頂点データからバッファを生成
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
	gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( triangleData.p ), gl.STATIC_DRAW );

	//	indexバッファの生成
	var indexBuffer = gl.createBuffer();
	gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
	gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Int16Array( triangleData.i ), gl.STATIC_DRAW );

	//	シェーダーとプログラムオブジェクト
	var vertexSource = document.getElementById('vertexshader').textContent;
	var fragmentSource = document.getElementById('fragmentshader').textContent;
	var programs = shaderProgram( vertexSource, fragmentSource );

	//	プログラムオブジェクトに三角形の頂点データを登録
	var attLocation = gl.getAttribLocation( programs, 'position' );
	gl.enableVertexAttribArray( attLocation );
	gl.vertexAttribPointer( attLocation, 3, gl.FLOAT, false, 0, 0 );

	//	matrix
	var mat = new matIV();
	var mMatrix = mat.identity( mat.create() );
	var vMatrix = mat.identity( mat.create() );
	var pMatrix = mat.identity( mat.create() );
	var vpMatrix = mat.identity( mat.create() );
	var mvpMatrix = mat.identity( mat.create() );

	//	ビュー座標変換行列
	var cameraPosition = [0.0, 0.0, 3.0];
	var focusPoint = [0.0,	0.0,	0.0];
	var cameraUp = [ 0.0,	1.0,	0.0];
	mat.lookAt( cameraPosition, focusPoint, cameraUp, vMatrix );

	//	プロジェクションのための情報を揃える
	var fov = 50;	//	視野角
	var aspect = canvas.width / canvas.height;	//	アスペクト比
	var near = 0.1;	//	空間の最前面
	var far = 10.0;	//	空間の奥行き終端
	mat.perspective( fov, aspect, near, far, pMatrix );

	//	行列掛け合わせ
	mat.multiply( pMatrix, vMatrix, vpMatrix );	//	pにvをかける
	mat.multiply( vpMatrix, mMatrix, mvpMatrix );	//	さらにmをかける

	//	アニメーション
	render();

	function shaderProgram( vertexSource, fragmentSource )
	{
		//	シェーダーとプログラムオブジェクト
		//var vertexSource = document.getElementById('vertexshader').textContent;
		//var fragmentSource = document.getElementById('fragmentshader').textContent;
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var programs = gl.createProgram();
		gl.shaderSource( vertexShader, vertexSource );
		gl.compileShader( vertexShader );
		gl.attachShader( programs, vertexShader );
		gl.shaderSource( fragmentShader, fragmentSource );
		gl.compileShader( fragmentShader );
		gl.attachShader( programs, fragmentShader );
		gl.linkProgram( programs );
		gl.useProgram( programs );
		return programs;
	}

	function genTriangle()
	{
		var obj = {};
		obj.p = [
		 0.0,  0.5, 0.0,
		 0.5, -0.5, 0.0,
		-0.5, -0.5, 0.0,
		 0.0, -0.5, 0.0,
		 0.5,  0.5, 0.0,
		-0.5,  0.5, 0.0
		];


		obj.p = [];
		var _max = 6;
		for( var i = 0; i < _max; i++ )
		{
			var _rad = i / _max * 360 / 180 * Math.PI;
			var _x = Math.cos( _rad ) * 0.5;
			var _y = Math.sin( _rad ) * 0.5;
			obj.p.push( _x );
			obj.p.push( _y );
			obj.p.push( 0 );
		}

		//
		return obj;
	}


	function render()
	{
		count ++;

		gl.clear( gl.COLOR_BUFFER_BIT );


		//	モデル座標変換行列を一度初期化してリセットする
		mat.identity( mMatrix );

		//	モデル座標変換行列

		//	モデル座標変換
		var _x = Math.cos( - count * 0.02 ) * 0.5;
		var _y = Math.sin( - count * 0.02 ) * 0.5;
		var move = [_x, _y, 0.0];
		//mat.translate( mMatrix, move, mMatrix );

		//	回転
		var radians = ( count % 360 ) * Math.PI / 180 * 3.0;
		var axis = [1.0,1.0,1.0];
		mat.rotate(mMatrix,radians,axis,mMatrix);

		//	スケール
		var _scale = Math.sin( count * 0.015 ) * 0.5 + 1;
		var ratio = [_scale,_scale,_scale];
		//mat.scale( mMatrix, ratio, mMatrix );


		//	vpマトリックスにモデル座標変換行列をかける
		mat.multiply( vpMatrix, mMatrix, mvpMatrix );

		//	シェーダーに転送
		var uniLocation = gl.getUniformLocation(programs, 'mvpMatrix');
		gl.uniformMatrix4fv(uniLocation, false, mvpMatrix);

		//	描画
		//	gl.drawArrays( gl.TRIANGLES, 0, triangleData.p.length / 3 );
		gl.drawArrays( null, 0, triangleData.p.length / 3 );
		//	gl.drawArrays( gl.LINE_LOOP, 0, triangleData.p.length / 3 );
		//	gl.drawElements( gl.LINE_STRIP, triangleData.i.length, gl.UNSIGNED_SHORT, 0 );
		//	gl.drawElements( gl.TRIANGLES, triangleData.i.length, gl.UNSIGNED_SHORT, 0 );
		gl.flush();

		window.requestAnimationFrame( render );


		//	2nd
		mat.identity( mMatrix );
		mat.translate( mMatrix, move, mMatrix );
		mat.rotate(mMatrix,radians,axis,mMatrix);
		mat.scale( mMatrix, ratio, mMatrix );
		mat.multiply( vpMatrix, mMatrix, mvpMatrix );
		var uniLocation = gl.getUniformLocation(programs, 'mvpMatrix');
		gl.uniformMatrix4fv(uniLocation, false, mvpMatrix);
		gl.drawArrays( null, 0, triangleData.p.length / 3 );
		gl.flush();

	}


})();
</script> 
</body>
</html>