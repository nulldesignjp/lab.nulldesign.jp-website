<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="">
<link rel="stylesheet" type="text/css" href="./shared/css/style.css" media="all">
<title>HACKist / WebGL VJ System ver 1.0.0</title>
<script type="x-shader/x-vertex" id="introV">
uniform vec2 resolution;
varying vec3 vUv;
void main()
{
	vUv = position.xyz;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="introF">
uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;
uniform vec3 skyColor;
varying vec3 vUv;
const int   oct  = 8;
const float per  = 0.5;
const float PI   = 3.1415926;
const float cCorners = 1.0 / 16.0;
const float cSides   = 1.0 / 8.0;
const float cCenter  = 1.0 / 4.0;
float interpolate(float a, float b, float x){
    float f = (1.0 - cos(x * PI)) * 0.5;
    return a * (1.0 - f) + b * f;
}
float rnd(vec2 p){
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}
float irnd(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec4 v = vec4(rnd(vec2(i.x,       i.y      )),
                  rnd(vec2(i.x + 1.0, i.y      )),
                  rnd(vec2(i.x,       i.y + 1.0)),
                  rnd(vec2(i.x + 1.0, i.y + 1.0)));
    return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);
}
float noise(vec2 p){
    float t = 0.0;
    for(int i = 0; i < oct; i++){
        float freq = pow(2.0, float(i));
        float amp  = pow(per, float(oct - i));
        t += irnd(vec2(p.x / freq, p.y / freq)) * amp;
    }
    return t;
}
float snoise(vec2 p, vec2 q, vec2 r){
    return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +
           noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +
           noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +
           noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);
}
void main()
{
	float scale = 0.01;
	vec3 color = vec3( skyColor.r, skyColor.g, skyColor.b );
	float power = noise( vec2( vUv.x * scale, vUv.y * scale - time * 4.0 ) );
	gl_FragColor = vec4( color * power * power, 1.0 );
}
</script>
<script type="x-shader/x-vertex" id="as555V">
uniform float time;
uniform vec2 resolution;
varying vec3 vUv;
void main()
{
    vUv = position.xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="as555F">
uniform float time;
uniform float startTime;
uniform vec2 resolution;
uniform vec2 mouse;
uniform vec3 skyColor;
varying vec3 vUv;
void main()
{
    vec3 p = normalize( vUv );
    vec3 _h = normalize( vUv );
    float _value = abs( sin(0.1) * 0.1 / _h.y );
    vec3 allColor = vec3( 0.0, 0.0, 0.0 );
    vec3 topColor = vec3( 0.1, 0.5, 0.8 );
    vec3 bottomColor = vec3( 0.1, 0.1, 0.1 );
    float myTime = time - startTime;
    myTime = ( myTime + 180.0 ) / 900.0;
    myTime = myTime>1.0?1.0:myTime;

    if( myTime > 0.8 )
    {
        float _pars = ( myTime - 0.8 ) / 2.0 * 10.0;
        topColor = vec3( 0.0, 0.2, 0.4 );
        bottomColor = vec3( 0.0, 0.1, 0.2 );
        vec3 addTop = vec3( 0.0, 0.0, 0.0 );
        vec3 addBottom = vec3( 0.0, 0.0, 0.1 );
        topColor += ( addTop - topColor ) * _pars;
        bottomColor += ( addBottom - bottomColor ) * _pars;
    } else if( myTime > 0.6 )
    {
        float _pars = ( myTime - 0.6 ) / 2.0 * 10.0;
        topColor = vec3( 0.05, 0.0, 0.1 );
        bottomColor = vec3( 0.8, 0.1, 0.1 );
        vec3 addTop = vec3( 0.0, 0.2, 0.4 );
        vec3 addBottom = vec3( 0.0, 0.1, 0.2 );
        topColor += ( addTop - topColor ) * _pars;
        bottomColor += ( addBottom - bottomColor ) * _pars;
    } else if( myTime > 0.4 )
    {
        float _pars = ( myTime - 0.4 ) / 2.0 * 10.0;
        vec3 addTop = vec3( 0.05, 0.0, 0.1 );
        vec3 addBottom = vec3( 0.8, 0.1, 0.1 );
        topColor += ( addTop - topColor ) * _pars;
        bottomColor += ( addBottom - bottomColor ) * _pars;
    } else {
      //  none
    }

    float par = ( p.y + 1.0 ) * 0.5;
    par = sin( par * 3.141592 * 0.5 );
    par = par*par*par*par*par;

    vec3 color = allColor + topColor * par + bottomColor * ( 1.0 - par );
    gl_FragColor = vec4( color * myTime * 2.0, 1.0 );
    gl_FragColor += vec4( vec3( _value ), 0.6 );
}
</script>
<script type="x-shader/x-vertex" id="floatAndFallsV">
uniform vec2 resolution;
varying vec3 vUv;
void main()
{
    vUv = position.xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="floatAndFallsF">
uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;
uniform vec3 skyColor;
varying vec3 vUv;
void main()
{
  vec2 position = gl_FragCoord.xy / resolution.xy;
  vec3 p = normalize( vUv );
  
  float par = ( p.y + 1.0 ) * 0.5;
  float parZ = ( p.z + 1.0 ) * 0.5;
  parZ = parZ*0.5 + 0.5;

  vec3 color = vec3( 0.0, 0.0, 0.0 );

  vec3 blue0 = vec3( 0.1725, 0.2235, 0.3019 );
  vec3 blue1 = vec3( 0.6902, 0.8078, 0.9451 );
  vec3 white = vec3( 1.0, 1.0, 1.0 );
  vec3 black = vec3( 0.2431, 0.2431, 0.3686 );

  if( par >= 0.5 )
  {
    float _wPar = ( par - 0.5 ) / 5.0 * 10.0;
    _wPar = sin( - ( 1.0 - _wPar ) * 3.141592 * 0.5 ) + 1.0;

    _wPar *= parZ;

    color += blue0 * _wPar + blue1 * ( 1.0 - _wPar );
  } else //if( par < 0.5 )
  {
    float _wPar = par * 2.0;
    _wPar *= parZ;
    color += black * _wPar;
  }

  gl_FragColor = vec4( color,1.0 );
    vec3 _h = normalize( vUv );
    float _value = abs( sin(0.1) * 0.1 / _h.y );
    gl_FragColor += vec4( vec3( _value ), 0.6 );
}
</script>
<script type="x-shader/x-vertex" id="lightWaveV">
uniform vec2 resolution;
varying vec3 vUv;
void main()
{
    vUv = position;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="lightWaveF">
uniform float time;
uniform vec2 resolution;
uniform vec3 skyColor;
uniform vec3 skyColor2;
uniform float sparkMode;
varying vec3 vUv;
float gt;
float hash( float n ) { return fract(sin(n)*753.5453123); }
float noise( in vec2 x )
{
    vec2 p = floor(x);
    vec2 f = fract(x);
    f = f*f*(3.0-2.0*f);
    
    float n = p.x + p.y*157.0;
    return mix(
                    mix( hash(n+  0.0), hash(n+  1.0),f.x),
                    mix( hash(n+157.0), hash(n+158.0),f.x),
            f.y);
}
float fbm(vec2 p, vec3 a)
{
     float v = 0.0;
     v += noise(p*a.x)*.5;
     v += noise(p*a.y)*.25;
     v += noise(p*a.z)*.125;
     return v;
}
vec3 drawLines( vec2 uv, vec3 fbmOffset, vec3 color1, vec3 color2 )
{
    float timeVal = gt * 0.0666;
    vec3 finalColor = vec3( 0.0 );
    for( int i=0; i < 5; ++i )
    {
        float indexAsFloat = float(i);
        float amp = 40.0 + (indexAsFloat*5.0);
        float period = 8.0 + (indexAsFloat+1.0);
        float thickness = 3.5*mix( 0.7, 1.0, noise(uv*10.0) );
        float t = abs( 0.2 / (sin(2.82 + 0.5 * uv.x + fbm( uv + timeVal * period, fbmOffset )) * amp) * thickness );
        finalColor +=  t * color1;
    }
    
    for( int i=0; i < 5; ++i )
    {
        float indexAsFloat = float(i);
        float amp = 30.0 + (indexAsFloat*7.0);
        float period = 8.0 + (indexAsFloat+.001);
        float thickness = 1.5*mix( 0.8, 1.0, noise(uv*10.0) );
        float t = abs( 0.5 / (sin(2.78 + 0.5 * uv.x + fbm( uv + timeVal * period, fbmOffset )) * amp) * thickness );
        finalColor +=  t * color2 * 0.6;
    }
    return finalColor * finalColor;
}
void main( void ) 
{
    vec2 p = ( vUv.xy / resolution.xy ) * 2.0 - 1.0;
    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
    if( sparkMode == 0.0 )
    {
      uv.x *= p.x/p.y;
      uv.xy = uv.yx;
    } else if(  sparkMode == 1.0 )
    {
      uv.xy = uv.yx;
    } else if( sparkMode == 2.0 )
    {
      uv.xy = uv.yx;
      uv *= uv.y;
    } else if( sparkMode == 3.0 ) {
      uv.x *= p.x/p.y;
      uv.xy = uv.yx;
    } else if( sparkMode == 4.0 ) {
      uv.x *= p.x/p.y;
      uv.xy = uv.yx;
      uv *= uv.y;
    } else if( sparkMode == 5.0 ) {
      uv.xy = vUv.yz*0.0001;
    } else if( sparkMode == 6.0 ) {
      uv.x *= p.x/p.y;
      uv.xy = uv.yx;
      uv /= vUv.z/10000.0;
    } else if( sparkMode == 7.0 ) {
      uv /= vUv.x / 10000.0;
    }
    vec3 lineColor1 = skyColor;
    vec3 lineColor2 = skyColor2;
    vec3 finalColor = vec3(0.0);
    gt = mod(time, 600.);
    float t = sin( gt ) * 0.5 + 0.5;
    float pulse = mix( 0.10, 0.20, t);
    finalColor += drawLines( uv, vec3( 1.0, 2.0, 4.0), lineColor1, lineColor2 );
    gl_FragColor = vec4( finalColor, 1.0 );
}
</script>
</head>
<body>
<div id="container"></div>
<div id="controll">
<div id="scenes">
<button id="scene01">Scene01</button>
<button id="scene02">Scene02</button>
<button id="scene03">Scene03</button>
</div>
<div id="effects">
<button id="effect1">Effect 01</button>
<button id="effect2">Effect 02</button>
</div>
<div id="kinects">
<button id="kinect01">SwipeLeft</button>
<button id="kinect03">HnadsUp</button>
<button id="kinect02">SwipeRight</button>
</div>
</div>
<div id="controllPC">
Scene: key 1,2 or 3<br>
Effect: space or enter<br>
Kinect: Arrow key
</div>
<h1 id="titleHead">HACKist / WebGL VJ System ver 1.0.0</h1>
<script src="./shared/js/jquery-2.1.3.min.js"></script>
<script src="./shared/js/SimplexNoise.js"></script>
<script src="./shared/js/three.min.js"></script>
<script src="./shared/js/THREE.ConvexGeometry.js"></script>
<script src="./shared/js/WorldVJ.js"></script>
<script src="./shared/js/scene00.js"></script>
<script src="./shared/js/scene02.js"></script>
<script src="./shared/js/scene04.js"></script>
<script src="./shared/js/scene05.js"></script>
<script src="./shared/js/utils.js"></script>
<script src="./shared/js/DEDEMOUSE.js"></script>
</body>
</html>