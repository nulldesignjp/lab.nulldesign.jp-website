/*
  THREE.DeDeShader


        _t.skyColor = new THREE.Color(1.0, 0.05, 0.05);
        _t.skyColorT = new THREE.Color(1.0, 0.05, 0.05);
        _t.skyColor2 = new THREE.Color(Math.random(), Math.random(), Math.random());
        _t.skyColorT2 = new THREE.Color(Math.random(), Math.random(), Math.random());

*/

THREE.DeDeShader = 
{
uniforms: 
{
    "time":     { type: "f", value: 0.0 },
    "speed":     { type: "f", value: 1.0 },
    "resolution": { type: "v2", value: new THREE.Vector2(0,0) },
    "skyColor": { type: "c", value: new THREE.Color(0x000000) },
    "skyColor2": { type: "c", value: new THREE.Color(0x000000) },
    "sparkMode":     { type: "f", value: 1.0 },
},

vertexShader:
[
"uniform vec2 resolution;",
"varying vec3 vUv;",
"void main()",
"{",
"vUv = position;",
"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
"}",
].join("\n"),

fragmentShader:
[
"uniform float time;",
"uniform float speed;",
"uniform vec2 resolution;",
"uniform vec3 skyColor;",
"uniform vec3 skyColor2;",
"uniform float sparkMode;",
"varying vec3 vUv;",
"float gt;",
"float hash( float n ) { return fract(sin(n)*753.5453123); }",
"float noise( in vec2 x )",
"{",
"vec2 p = floor(x);",
"vec2 f = fract(x);",
"f = f*f*(3.0-2.0*f);",
"float n = p.x + p.y*157.0;",
"return mix(",
"mix( hash(n+  0.0), hash(n+  1.0),f.x),",
"mix( hash(n+157.0), hash(n+158.0),f.x),",
"f.y);",
"}",
"float fbm(vec2 p, vec3 a)",
"{",
"float v = 0.0;",
"v += noise(p*a.x)*.5;",
"v += noise(p*a.y)*.25;",
"v += noise(p*a.z)*.125;",
"return v;",
"}",
"vec3 drawLines( vec2 uv, vec3 fbmOffset, vec3 color1, vec3 color2 )",
"{",
"float timeVal = gt * 0.0666 * speed;",
"vec3 finalColor = vec3( 0.0 );",
"for( int i=0; i < 5; ++i )",
"{",
"float indexAsFloat = float(i);",
"float amp = 40.0 + (indexAsFloat*5.0);",
"float period = 8.0 + (indexAsFloat+1.0);",
"float thickness = 3.5*mix( 0.7, 1.0, noise(uv*10.0) );",
"float t = abs( 0.2 / (sin(2.82 + 0.5 * uv.x + fbm( uv + timeVal * period, fbmOffset )) * amp) * thickness );",
"finalColor +=  t * color1;",
"}",
"for( int i=0; i < 5; ++i )",
"{",
"float indexAsFloat = float(i);",
"float amp = 30.0 + (indexAsFloat*7.0);",
"float period = 8.0 + (indexAsFloat+.001);",
"float thickness = 1.5*mix( 0.8, 1.0, noise(uv*10.0) );",
"float t = abs( 0.5 / (sin(2.78 + 0.5 * uv.x + fbm( uv + timeVal * period, fbmOffset )) * amp) * thickness );",
"finalColor +=  t * color2 * 0.6;",
"}",
"return finalColor * finalColor;",
"}",
"void main( void ) ",
"{",
"vec2 p = ( vUv.xy / resolution.xy ) * 2.0 - 1.0;",
"vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;",
"if( sparkMode == 0.0 )",
"{",
"uv.x *= p.x/p.y;",
"uv.xy = uv.yx;",
"} else if(  sparkMode == 1.0 )",
"{",
"uv.xy = uv.yx;",
"} else if( sparkMode == 2.0 )",
"{",
"uv.xy = uv.yx;",
"uv *= uv.y;",
"} else if( sparkMode == 3.0 ) {",
"uv.x *= p.x/p.y;",
"uv.xy = uv.yx;",
"} else if( sparkMode == 4.0 ) {",
"uv.x *= p.x/p.y;",
"uv.xy = uv.yx;",
"uv *= uv.y;",
"} else if( sparkMode == 5.0 ) {",
"uv.xy = vUv.yz*0.0001;",
"} else if( sparkMode == 6.0 ) {",
"uv.x *= p.x/p.y;",
"uv.xy = uv.yx;",
"uv /= vUv.z/10000.0;",
"} else if( sparkMode == 7.0 ) {",
"uv /= vUv.x / 10000.0;",
"}",
"vec3 lineColor1 = skyColor;",
"vec3 lineColor2 = skyColor2;",
"vec3 finalColor = vec3(0.0);",
"gt = mod(time, 1600.);",
"float t = sin( gt ) * 0.5 + 0.5;",
"float pulse = mix( 0.10, 0.20, t);",
"finalColor += drawLines( uv, vec3( 1.0, 2.0, 4.0), lineColor1, lineColor2 );",
"gl_FragColor = vec4( finalColor, 1.0 );",
"}"
].join("\n")
}

