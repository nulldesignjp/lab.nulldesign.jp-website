<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS">
<title>DE DE MOUSE + HACKist</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
	color: #FFF;
	font-size: 12px;
	font-family: Arial;
}
#container{
	width: 100%;
	height: 100%;
}

h1,p{
	margin: 0;
	padding: 0;
	line-height: 1;
	position: fixed;
	z-index: 100;
	font-size: 1em;
}
h1{
	left: 32px;
	top: 32px;
}
p{
	left: 32px;
	bottom: 32px;
}
</style>
</head>
<body>
<h1>流</h1>
<div id="container"></div>
<script src="../js/jquery-2.1.3.min.js"></script>
<script src="../js/Detector.js"></script>
<script src="../js/perlin-noise-simplex.js"></script>
<script src="../js/r71/three.min.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/THREE.ConvexGeometry.js"></script>
<script src="world3d.js"></script>
<script type="text/javascript">

    var _scale = screen.width / ( 1280 * 3 );
    var _top = Math.floor( ( screen.height - 1024 * _scale ) * 0.5 );
    window.moveTo( 0, _top );
    window.resizeTo( 1280 * 3  * _scale, 1024 * _scale );

(function(){
	var _tr = 0x66 / 0xFF;
	var _tg = 0x99 / 0xFF;
	var _tb = 0xCC / 0xFF;
	var __r = _tr;
	var __g = _tg;
	var __b = _tb;
	var _size = 600;
	var _hsize = _size * 0.5;
	var lineNums = 1024;
	var lineLenght = 24;
	var _initSpeed = 2.0;
	var _speed = 0.26 * 2;
	var _scale = 1.6;
	var _frection = 0.96;
	var _is3d = true;
	var _changeDuration = 4.0;
	var simplexNoiseX = new SimplexNoise();
	var simplexNoiseY = new SimplexNoise();
	var simplexNoiseZ = new SimplexNoise();
	var _cube;
	var _lineMaterial;
	var _lineList = [];
	var _wheelValue = 1200;

	var _audioScale = 1.6;
	var _volume = 1.0;
	var _volumeMin = 0.1;
	var _volumeMax = 1.0 * _audioScale;

	_volume = _volumeMin;

	//	threejs
	var _dom = document.getElementById('container');
	var _t = new world3d.three( _dom );
	_t.camera.position.set( 0, 0, _wheelValue );

	//
	_cube = new THREE.Object3D();
	_t.scene.add( _cube );

	//	init lines

	init();
	initAudio();
	start();

	_tr = Math.random();
	_tg = Math.random();
	_tb = Math.random();
	__r = _tr;
	__g = _tg;
	__b = _tb;


	//_t.camera.fov = 60;
	_t.camera.updateProjectionMatrix();

	//	FUNCTION
	function init()
	{
		var _material = new THREE.LineBasicMaterial({linewidth:1,color: new THREE.Color(__r,__g,__b), transparent:true,opacity:0.6});
		_lineMaterial = _material;
		for( var i = 0; i < lineNums; i++ )
		{
			var _geometry = new THREE.Geometry();
			_geometry.verticesNeedUpdate = true;
			_geometry.dynamic = true;

				//(Math.random()-.5)*_size,(Math.random()-.5)*_size,(Math.random()-.5)*_size
				var _x = (Math.random()-.5)*_size;
				var _y = (Math.random()-.5)*_size;
				var _z = (Math.random()-.5)*_size;
			for( var j = 0; j < lineLenght; j++ )
			{
				_geometry.vertices[j] = new THREE.Vector3( _x, _y, _z );
			}
			var _mesh = new THREE.Line( _geometry, _material );
			_cube.add( _mesh );

			var _vx = Math.random() * 2 - 1;
			var _vy = Math.random() * 2 - 1;
			var _vz = Math.random() * 2 - 1;
			_vx *= _initSpeed;
			_vy *= _initSpeed;
			_vz *= _initSpeed;

			_lineList.push({
				geometry:_geometry,
				vx: _vx,
				vy: _vy,
				vz: _vz
			});
		}

		lineBox();

	}
	function lineBox()
	{
		var _material = new THREE.LineBasicMaterial({linewidth:1,color: 0xFFFFFF,transparent:true,opacity: 0.4});
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,_hsize,_hsize );
		_geometry.vertices[2] = new THREE.Vector3( -_hsize,_hsize,-_hsize );
		_geometry.vertices[3] = new THREE.Vector3( _hsize,_hsize,-_hsize );
		_geometry.vertices[4] = new THREE.Vector3( _hsize,_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,-_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,-_hsize,_hsize );
		_geometry.vertices[2] = new THREE.Vector3( -_hsize,-_hsize,-_hsize );
		_geometry.vertices[3] = new THREE.Vector3( _hsize,-_hsize,-_hsize );
		_geometry.vertices[4] = new THREE.Vector3( _hsize,-_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( _hsize,-_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( -_hsize,_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,-_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( -_hsize,_hsize,-_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,-_hsize,-_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,_hsize,-_hsize );
		_geometry.vertices[1] = new THREE.Vector3( _hsize,-_hsize,-_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
	}

	function start()
	{
		setInterval(function(){
			simplexNoiseX = new SimplexNoise();
			simplexNoiseY = new SimplexNoise();
			simplexNoiseZ = new SimplexNoise();

			_tr = Math.floor( Math.random() * 0xCC + 0x33 ) / 0xFF;
			_tg = Math.floor( Math.random() * 0xCC + 0x33 ) / 0xFF;
			_tb = Math.floor( Math.random() * 0xCC + 0x33 ) / 0xFF;
		},1000 * _changeDuration);
		setInterval(function(){

			_wheelValue = Math.sin( Date.now() * 0.0001 ) * 400 + 600;

			__r += ( _tr - __r ) * 0.01;
			__g += ( _tg - __g ) * 0.01;
			__b += ( _tb - __b ) * 0.01;

			_lineMaterial.color = new THREE.Color( __r,__g,__b );
			_lineMaterial.linewidth = _volume * 5.0;

			//	CUBE
			_cube.rotation.x = world3d.time * 0.0036;
			_cube.rotation.y = world3d.time * 0.0024;

			//	CAMERA
			var _x = world3d.mouse.x / world3d.resolution.x - 0.5;
			var _y = world3d.mouse.y / world3d.resolution.y - 0.5;
			//_x *= - world3d.resolution.x * 2.0;
			//_y *= world3d.resolution.y * 2.0;
			_t.camera.position.x += ( _x - _t.camera.position.x ) * 0.2;
			_t.camera.position.y += ( _y - _t.camera.position.y ) * 0.2;
			_t.camera.position.z += ( _wheelValue - _t.camera.position.z ) * 0.2;


			_t.camera.lookAt( world3d.ZERO );

			//	LINE
			var len = _lineList.length;
			while( len )
			{
				len--;
				var _obj = _lineList[len];
				var _vertices = _obj.geometry.vertices;
				var _px = _vertices[0].x;
				var _py = _vertices[0].y;
				var _pz = _vertices[0].z;

				var len0 = _vertices.length;
				for( var i = 0; i < len0; i++ )
				{
					var __px = _vertices[i].x;
					var __py = _vertices[i].y;
					var __pz = _vertices[i].z;

					_vertices[i].x = _px;
					_vertices[i].y = _py;
					_vertices[i].z = _pz;

					_px = __px;
					_py = __py;
					_pz = __pz;
				}
				_vertices[0].x += _obj.vx * _volume;
				_vertices[0].y += _obj.vy * _volume;
				_vertices[0].z += _obj.vz * _volume;

				_obj.vx += simplexNoiseX.noise( ( _vertices[0].z + _hsize ) / _size * _scale, ( _vertices[0].y + _hsize ) / _size * _scale ) * _speed;
				_obj.vy += simplexNoiseY.noise( ( _vertices[0].x + _hsize ) / _size * _scale, ( _vertices[0].z + _hsize ) / _size * _scale ) * _speed;
				_obj.vz += simplexNoiseZ.noise( ( _vertices[0].y + _hsize ) / _size * _scale, ( _vertices[0].x + _hsize ) / _size * _scale ) * _speed;

				//	air frection
				_obj.vx *= _frection;
				_obj.vy *= _frection;
				_obj.vz *= _frection;

				// _obj.vx += (Math.random()-.5)*.5;
				// _obj.vy += (Math.random()-.5)*.5;
				// _obj.vz += (Math.random()-.5)*.5;

				//	pseudo grav
				_vertices[0].x += ( 0 - _vertices[0].x ) * 0.005;
				_vertices[0].y += ( 0 - _vertices[0].y ) * 0.005;
				_vertices[0].z += ( 0 - _vertices[0].z ) * 0.005;

				//
				if( _vertices[0].x < -_hsize )
				{
					_vertices[0].x = -_hsize;
					_obj.vx *= - ( Math.random() * .2 + .9 );

				} else if( _vertices[0].x > _hsize )
				{
					_vertices[0].x = _hsize;
					_obj.vx *= - ( Math.random() * .2 + .9 );
				}
				if( _vertices[0].y < -_hsize )
				{
					_vertices[0].y = -_hsize;
					_obj.vy *= - ( Math.random() * .2 + .9 );
				} else if( _vertices[0].y > _hsize )
				{
					_vertices[0].y = _hsize;
					_obj.vy *= - ( Math.random() * .2 + .9 );
				}
				if( _vertices[0].z < -_hsize )
				{
					_vertices[0].z = -_hsize;
					_obj.vz *= - ( Math.random() * .2 + .9 );
				} else if( _vertices[0].z > _hsize )
				{
					_vertices[0].z = _hsize;
					_obj.vz *= - ( Math.random() * .2 + .9 );
				}
				_obj.geometry.verticesNeedUpdate = true;
			}
		},1000/60);
	}

	function createPlane()
	{
		var _geometry = new THREE.PlaneGeometry( _size, _size, 1, 1 );
		var _material = new THREE.MeshPhongMaterial({side:THREE.DoubleSide,transparent:true,opacity: 0.6});
		var _mesh = new THREE.Mesh( _geometry, _material );
		return _mesh;
	}

	function initAudio()
	{
		var _size = 2048;
		var audioContext;
		var filter;
		var analyser;
		var _intervalKey;

		window.AudioContext = window.AudioContext || window.webkitAudioContext;
		try
		{
			// Create the instance of AudioContext
			audioContext = new AudioContext();

			filter = audioContext.createBiquadFilter();
			filter.type = 0;
			filter.frequency.value = 440;

			analyser = audioContext.createAnalyser();
			//	http://curtaincall.weblike.jp/portfolio-web-sounder/webaudioapi-visualization/demos/demo-03
			//	fftSize: 高速フーリエ変換のデータサイズ	2048
			//	frequencyBinCount: fftSizeプロパティの1 / 2の値
			//	minDecibels: getByteFrequencyDataメソッドで取得可能なデシベルの下限
			//	maxDecibels: getByteFrequencyDataメソッドで取得可能なデシベルの上限
			//	smoothingTimeConstant: 周波数領域の波形 (振幅スペクトル) 描画に関連するプパティ
			//	getByteTimeDomainData(array): 時間領域の波形データを取得するメソッド
			//	getByteFrequencyData(array): 周波数領域の波形データ (振幅スペクトル) を取得するメソッド
			//	getFloatFrequencyData(array): 周波数領域の波形データ (振幅スペクトル) をデシベル単位で取得するメソッド
			analyser.fftSize = 2048;

			analyser.minDecibels = -120;	//	0
			analyser.maxDecibels = -30;		//	255


			//
			var audioObj = {"audio":true};

			var errBack = function(e){
				console.log("Web Audio error:",e.code);
			};

			//WebAudioリクエスト成功時に呼び出されるコールバック関数
			function gotStream(stream)
			{
				//streamからAudioNodeを作成
				var mediaStreamSource = audioContext.createMediaStreamSource(stream);
				mediaStreamSource.connect(filter);

				filter.connect(analyser);
				//出力Nodeのdestinationに接続
				analyser.connect(audioContext.destination);
				//mediaStreamSource.connect(audioContext.destination);

				_nextStep();
			}

			//マイクの有無を調べる
			if(navigator.webkitGetUserMedia)
			{
				//マイク使って良いか聞いてくる
				navigator.webkitGetUserMedia(audioObj,gotStream,errBack);
			}else{
				console.log("マイクデバイスがありません");
			}


		} catch (error) {
			alert(error.message + ' : Please use Chrome or Safari.');
			return;
		}

		function _nextStep()
		{
			_intervalKey = setInterval(function(){

				var data = new Float32Array( analyser.frequencyBinCount );
	            analyser.getFloatFrequencyData( data );
	            var sum = 0;
	            var len = data.length;
	            for(var i = 0; i < len; ++i)
	            {
	            	//上部の描画
	            	sum += ( 255 + data[i] ) / 255;
	            	//_ctx5.fillRect( i*1, _h, 1, - ( 255 + data[i] ) / 255 * _h );
	            }

	            //	ave
	            sum /= len;
	            sum *= _audioScale;
	            sum = sum<_volumeMin?sum:sum>_volumeMax?_volumeMax:sum;
	            _volume += ( sum - _volume ) * 0.05;

	            //console.log( sum, len );

	            //console.log( _volume )
			},1000/60);
		}
	}

})();
</script>
</body>
</html>