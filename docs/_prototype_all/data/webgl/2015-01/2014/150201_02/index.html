<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS, SHADER">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
}
#container{
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="../js/jquery-2.1.1.min.js"></script>
<script src="../js/Tweener.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/three.min.js"></script><!--/ v70 -->
<script id="vertexShader" type="x-shader/x-vertex">
void main( void ) 
{
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
void main( void ) 
{
	vec2 p = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
	vec3 c = vec3( 0.0, 0, 0 );
	float amplitude = 0.10; 
	float glowT = sin(time) * 0.5 + 0.5;
	float glowFactor = mix( 0.15, 0.35, glowT );
	c += vec3(0.02, 0.03, 0.13) * ( glowFactor * abs( 1.0 / sin(p.x + sin( p.y + time ) * amplitude ) ));
	c += vec3(0.02, 0.10, 0.03) * ( glowFactor * abs( 1.0 / sin(p.x + sin( p.y + time+1.00 ) * amplitude+0.1 ) ));
	c += vec3(0.13, 0.02, 0.03) * ( glowFactor * abs( 1.0 / sin(p.x + sin( p.y + time+2.00 ) * amplitude+0.2 ) ));
	
	gl_FragColor = vec4( c, 1.0 );
}
</script>
<script type="text/javascript">
window.addEventListener("load", function (){

	//	uniforms
	var uniforms = {
		time: { type: "f", value: 1.0 },
		resolution: { type: "v2", value: new THREE.Vector2() },
		mouse: { type: "v2", value: new THREE.Vector2() }
	};
	uniforms.time.value = 0.0;
	uniforms.resolution.value.x = window.innerWidth;
	uniforms.resolution.value.y = window.innerHeight;
	uniforms.mouse.value.x = 0;
	uniforms.mouse.value.y = 0;

	//	world
	var _dom = document.getElementById('container');
	var _vertexShader = document.getElementById('vertexShader').textContent;
	var _fragmentShader = document.getElementById('fragmentShader').textContent;
	var _world = new istWorld.Shader( _dom, _vertexShader, _fragmentShader, uniforms );
	var mouse = istWorld.Main.mouse;

	//	start
	createStats();
	animate();

	//	events
	window.addEventListener( 'resize', onWindowResize, false );
	$( window ).on( 'mousemove', _onMouseMove );
	$( window ).on( 'touchmove', _onTouchMove );


	//	method
	function createStats()
	{
		stats = new Stats();
		stats.domElement.style.position = 'fixed';
		stats.domElement.style.left = "0px";
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );
	}
	function animate()
	{
		stats.update();

		requestAnimationFrame( animate );
		loop();
	}
	function loop()
	{
		var _time = Date.now() * 0.001;
	}

	//	Handler
	function onWindowResize()
	{
		_world.camera.aspect = window.innerWidth / window.innerHeight;
		_world.camera.updateProjectionMatrix();
		_world.renderer.setSize( window.innerWidth, window.innerHeight );

		uniforms.resolution.value.x = window.innerWidth;
		uniforms.resolution.value.y = window.innerHeight;

		istWorld.Main.resolution = {x:window.innerWidth,y:window.innerHeight};
	}

	function _onMouseMove(e)
	{
		e.preventDefault();
		mouse.x = e.originalEvent.pageX;
		mouse.y = e.originalEvent.pageY;

		uniforms.mouse.value.x = mouse.x;
		uniforms.mouse.value.y = mouse.y;
	}
	function _onTouchMove(e)
	{
		e.preventDefault();
		mouse.x = e.originalEvent.touches[0].pageX;
		mouse.y = e.originalEvent.touches[0].pageY;
	}

});

/**
*	custom class
*	v 70
*	
*
*/
var istWorld;
(function(istWorld){
	var main = (function(){
		function main( _dom )
		{
			//	props
			this.scene;
			this.camera;
			this.focus;
			this.renderer;

			//	init
			this.init3D( _dom );
			this.animate();
		}

		//	Mouse
		main.mouse = {x:window.innerWidth*0.5,y:window.innerHeight*0.5};

		//	resolution
		main.resolution = {x:window.innerWidth,y:window.innerHeight}

		//	is enable WebGL?[boolean]
		main.isSupportedWebgl = function () {
            try {
                var canvas = document.createElement("canvas");
                return !!window["WebGLRenderingContext"] && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
            }
            catch (e) {
                return false;
            }
        };
        main.ZERO = new THREE.Vector3(0, 0, 0);
        //main.PROJECTOR = new THREE.Projector();

		main.prototype = {
			init3D	:	function( _dom )
			{
				var _width = window.innerWidth;
				var _height = window.innerHeight;

				//	カメラ
				this.camera = new THREE.PerspectiveCamera( 50, _width / _height, 0.1, 2000 );
				this.camera.position.z = 1000;

				//	カメラフォーカス	
				this.focus = new THREE.Vector3();
				this.focus.set( 0, 0, 0 );
				this.camera.lookAt( focus );

				//	SCENE
				this.scene = new THREE.Scene();
				this.scene.fog = new THREE.Fog( 0x181818, 1000, 2000 );

				//	renderer
				this.renderer = new THREE.WebGLRenderer( { antialias: false } );
				this.renderer.setClearColor( this.scene.fog.color, 1 );
				this.renderer.setSize( window.innerWidth, window.innerHeight );
				this.renderer.gammaInput = true;
				this.renderer.gammaOutput = true;

				_dom.appendChild( this.renderer.domElement );
			},
			animate	:	function()
			{
				//requestAnimationFrame( this.animate );
				//this.render();
				var _this = this;
				setInterval(function(){
					_this.render();
				},1000/60);
			},
			render	:	function()
			{
				var _this = this;
				_this.camera.lookAt( _this.focus );
				_this.renderer.render( _this.scene, _this.camera );
			}
		}

		return main;
	})();
	istWorld.Main = main;

	var shader = (function(){
		function shader( _dom, _vid, _fid, _uniforms )
		{
			//	props
			this.scene;
			this.camera;
			this.focus;
			this.renderer;

			//
			this.vid = _vid;
			this.fid = _fid;
			this.uniforms = _uniforms;

			//	init
			this.init3D( _dom );
			this.createScreen();
			this.animate();

		}

		shader.prototype = {
			init3D	:	function( _dom )
			{
				var _width = window.innerWidth;
				var _height = window.innerHeight;

				//	カメラ
				this.camera = new THREE.PerspectiveCamera( 50, _width / _height, 1, 1000 );
				this.camera.position.z = 1;

				//	カメラフォーカス	
				this.focus = new THREE.Vector3();
				this.focus.set( 0, 0, 0 );
				this.camera.lookAt( focus );

				//	SCENE
				this.scene = new THREE.Scene();
				this.scene.fog = new THREE.Fog( 0x181818, 1000, 2000 );
				this.scene.add( new THREE.AmbientLight( 0x050505 ) );

				//	renderer
				this.renderer = new THREE.WebGLRenderer( { antialias: false } );
				this.renderer.setClearColor( this.scene.fog.color, 1 );
				this.renderer.setSize( window.innerWidth, window.innerHeight );
				this.renderer.gammaInput = true;
				this.renderer.gammaOutput = true;

				_dom.appendChild( this.renderer.domElement );
			},
			createScreen	:	function()
			{
				var geometry = new THREE.PlaneBufferGeometry( 2, 2 );
				var material = new THREE.ShaderMaterial({
					uniforms: this.uniforms,
					vertexShader: this.vid,
					fragmentShader: this.fid
					//vertexShader: document.getElementById( this.vid ).textContent,
					//fragmentShader: document.getElementById( this.fid ).textContent
				} );

				var mesh = new THREE.Mesh( geometry, material );
				this.scene.add( mesh );
			},
			animate	:	function()
			{
				//requestAnimationFrame( this.animate );
				//this.render();
				var _this = this;
				setInterval(function(){
					_this.render();
					_this.uniforms.time.value += 0.05;
				},1000/60);
			},
			render	:	function()
			{
				var _this = this;
				_this.camera.lookAt( _this.focus );
				_this.renderer.render( _this.scene, _this.camera );
			}
		}
		return shader;
	})();
	istWorld.Shader = shader;
})(istWorld||(istWorld={}));
</script>
</body>
</html>