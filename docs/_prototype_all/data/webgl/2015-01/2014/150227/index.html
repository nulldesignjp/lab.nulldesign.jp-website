<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
}
#container{
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="../js/jquery-2.1.1.min.js"></script>
<script src="../js/Detector.js"></script>
<script src="../js/three.min.js"></script>
<script type="x-shader/x-vertex" id="vertexshader">
uniform float amplitude;
uniform float scale;
attribute float size;
attribute vec3 customColor;
varying vec3 vColor;
void main()
{
	vColor = customColor;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = size * scale;
	//gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) ) * scale * 10.0;
	gl_Position = projectionMatrix * mvPosition;
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
uniform vec3 color;
uniform sampler2D texture;
void main()
{
	gl_FragColor = vec4( color * vColor, 1.0 );
	//gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
}
</script>
<script type="text/javascript">
(function(){
	var container
	var camera
	var focus
	var scene
	var renderer
	var mouse = {x:$( window ).height() * 0.5,y:$( window ).width() * 0.5};

	var attributes = {
		size: {	type: 'f', value: [] },
		customColor: { type: 'c', value: [] }
	};
	var uniforms = {
		amplitude: { type: "f", value: 1.0 },
		color:     { type: "c", value: new THREE.Color( 0xffffff ) },
		scale:     { type: "f", value: 1.0 },
		texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "spark1.png" ) },
	};

	var _list = [];

	//	
	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

	init3D();
	setupEnvironment();
	createObject();
	animate();


	//	events
	window.addEventListener( 'resize', onWindowResize, false );
	$( window ).on( 'mousemove', _onMouseMove );
	$( window ).on( 'touchmove', _onTouchMove );

	function onWindowResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function _onMouseMove(e)
	{
		e.preventDefault();
		mouse.x = e.originalEvent.pageX;
		mouse.y = e.originalEvent.pageY;
	}
	function _onTouchMove(e)
	{
		e.preventDefault();
		mouse.x = e.originalEvent.touches[0].pageX;
		mouse.y = e.originalEvent.touches[0].pageY;
	}

	function init3D()
	{
		var _width = window.innerWidth;
		var _height = window.innerHeight;
		
		//	器
		container = document.getElementById('container');

		//	カメラ
		camera = new THREE.PerspectiveCamera( 24, _width / _height, 0.1, 2000 );
		camera.position.set( 0, 300, 1000 );

		//	カメラフォーカス	
		focus = new THREE.Vector3();
		focus.set( 0, 0, 0 );
		camera.lookAt( focus );

		//	SCENE
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x181818, 1000, 2000 );

		//	renderer
		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setClearColor( scene.fog.color, 1 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.gammaInput = true;
		renderer.gammaOutput = true;

		container.appendChild( renderer.domElement );
	}

	function setupEnvironment()
	{
		//	環境光（最小限の光的なの。適度に暗い方が質感が出る
		scene.add( new THREE.AmbientLight( 0x181818 ) );

		//	LIGHT
		var light = new THREE.DirectionalLight( 0x181818 );
		light.position.set( 1, 1, 1 );
		light.intensity = 1;
		scene.add( light );
	}
	var _pc;
	function createObject()
	{

		var geometry = new THREE.PlaneGeometry(3000,3000,100,100);
		var material = new THREE.MeshPhongMaterial({shading:THREE.SmoothShading});
		//var material = new THREE.MeshLambertMaterial({shading:THREE.SmoothShading});
		//var material = new THREE.MeshNormalMaterial({shading:THREE.SmoothShading});
		var mesh = new THREE.Mesh(geometry, material);
		mesh.rotation.x = - Math.PI * 0.5
		scene.add( mesh );

		var geometry = new THREE.IcosahedronGeometry(40,1);
		var material = new THREE.MeshLambertMaterial({shading:THREE.NoShading});
		var mesh = new THREE.Mesh(geometry, material);
		mesh.position.set( 200, 100, 100 );
		scene.add( mesh );

		var geometry = new THREE.IcosahedronGeometry(40,1);
		var material = new THREE.MeshLambertMaterial({shading:THREE.NoShading});
		var mesh = new THREE.Mesh(geometry, material);
		mesh.position.set( -200, 100, 100 );
		scene.add( mesh );

		var geometry = new THREE.IcosahedronGeometry(40,1);
		var material = new THREE.MeshLambertMaterial({shading:THREE.NoShading});
		var mesh = new THREE.Mesh(geometry, material);
		mesh.position.set( 200, 100, -100 );
		scene.add( mesh );

		var geometry = new THREE.IcosahedronGeometry(40,1);
		var material = new THREE.MeshLambertMaterial({shading:THREE.NoShading});
		var mesh = new THREE.Mesh(geometry, material);
		mesh.position.set( -200, 100, -100 );
		scene.add( mesh );


		//
		var shaderMaterial = new THREE.ShaderMaterial( {
			uniforms:       uniforms,
			attributes:     attributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			blending:       THREE.AdditiveBlending,
			depthTest:      false,
			transparent:    true
		});

		var _pcm = new THREE.PointCloudMaterial({color: 0x99CCFF,size:30,map:THREE.ImageUtils.loadTexture( "spark1.png" ),blending:THREE.AdditiveBlending,depthTest:false,transparent:true});

		var geometry = new THREE.Geometry();
		for( var i = 0; i < 60; i++ )
		{
			geometry.vertices[i] = new THREE.Vector3( 0, Math.random() * 600 + 100, 0 );
			var light = new THREE.PointLight( 0x99ccFF, 1.0, 300 );
			scene.add( light );
			_list.push( {'mesh': light, vx: rv() * 10, vy: rv() * 10, vz: rv() * 10 } );

		}
		_pc = new THREE.PointCloud( geometry, _pcm );
		scene.add( _pc );
		_pc.geometry.verticesNeedUpdate = true;
		render();

	}

	function rv()
	{
		return Math.random() - 0.5;
	}

	function animate()
	{
		requestAnimationFrame( animate );
		render();
	}

	function render()
	{
		var len = _list.length;
		while( len )
		{
			len--;
			var _par = _pc.geometry.vertices[len];
			var _obj = _list[len];

			var _dx = _par.x + _obj.vx;
			var _dy = _par.y + _obj.vy;
			var _dz = _par.z + _obj.vz;


			_obj.vy --;
			if( _dy < 1 )
			{
				_dy = 1;
				_obj.vy *= - 0.5;
			}

			_obj.mesh.position.set( _dx, _dy, _dz );

			_par.x = _dx;
			_par.y = _dy;
			_par.z = _dz;

			if( _dx < -1000 || _dx > 1000 | _dz < -1000 || _dz > 1000 )
			{
				_obj.mesh.position.set( rv() * 100, 200 + rv() * 100, rv() * 100 );
				_par.x = _obj.mesh.position.x;
				_par.y = _obj.mesh.position.y;
				_par.z = _obj.mesh.position.z;
			}
		}
		_pc.geometry.verticesNeedUpdate = true;

		var _time = Date.now() * 0.001;
		camera.lookAt( focus );
		renderer.render( scene, camera );
	}

})();
</script>
</body>
</html>