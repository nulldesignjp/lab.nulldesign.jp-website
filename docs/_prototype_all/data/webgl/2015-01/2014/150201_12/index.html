<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS, SHADER, pftest - 3">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #FFF;
}
#container{
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="../js/jquery-2.1.1.min.js"></script>
<script src="../js/Tweener.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/three.min.js"></script><!--/ v70 -->
<script id="vertexShader" type="x-shader/x-vertex">
void main( void ) 
{
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

const float PI = 3.141592;

//uniform sampler2D backbuffer;
//http://stackoverflow.com/questions/19872524/threejs-fragment-shader-using-recycled-frame-buffers
//http://glslsandbox.com/e#22776.0

void main( void ) 
{
	float size = 30.0;
	float color = 0.0;

	//	color
	//	vec3 mColor = vec3( 1.0, ( gl_FragCoord.xy / resolution.xy ) );
	vec3 mColor = vec3( (sin(time * 0.1)+1.0)*0.5, ( gl_FragCoord.xy / resolution.xy ) );

	float r = 100.0;
	float speed = 2.0;
	color += size / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((0.0*120.0)/180.0*PI-time*speed) * r, sin((0.0*120.0)/180.0*PI-time*speed) * r ) );
	color += size / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((1.0*120.0)/180.0*PI-time*speed) * r, sin((1.0*120.0)/180.0*PI-time*speed) * r ) );
	color += size / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((2.0*120.0)/180.0*PI-time*speed) * r, sin((2.0*120.0)/180.0*PI-time*speed) * r ) );

	color += size * 0.2 / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((0.5*120.0)/180.0*PI+time*speed) * r * 0.5, sin((0.5*120.0)/180.0*PI+time*speed) * r * 0.5 ) );
	color += size * 0.2 / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((1.5*120.0)/180.0*PI+time*speed) * r * 0.5, sin((1.5*120.0)/180.0*PI+time*speed) * r * 0.5 ) );
	color += size * 0.2 / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((2.5*120.0)/180.0*PI+time*speed) * r * 0.5, sin((2.5*120.0)/180.0*PI+time*speed) * r * 0.5 ) );

	color += size * 0.05 / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((0.0*120.0)/180.0*PI-time*speed) * r * 0.2, sin((0.0*120.0)/180.0*PI-time*speed) * r * 0.2 ) );
	color += size * 0.05 / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((1.0*120.0)/180.0*PI-time*speed) * r * 0.2, sin((1.0*120.0)/180.0*PI-time*speed) * r * 0.2 ) );
	color += size * 0.05 / distance( gl_FragCoord.xy, mouse.xy + vec2( cos((2.0*120.0)/180.0*PI-time*speed) * r * 0.2, sin((2.0*120.0)/180.0*PI-time*speed) * r * 0.2 ) );


	gl_FragColor = vec4( vec3( color ) * mColor, 1.0 );
}
</script>
<script type="text/javascript">
window.addEventListener("load", function (){

	//	uniforms
	var uniforms = {
		time: { type: "f", value: 1.0 },
		resolution: { type: "v2", value: new THREE.Vector2() },
		mouse: { type: "v2", value: new THREE.Vector2() }
		//backbuffer: { type: "t", value: THREE.ImageUtils.loadTexture( "../img/UV_Grid_Sm.jpg" ) }

	};
	uniforms.time.value = 0.0;
	uniforms.resolution.value.x = window.innerWidth;
	uniforms.resolution.value.y = window.innerHeight;
	uniforms.mouse.value.x = 0;
	uniforms.mouse.value.y = 0;

	//	world
	var _dom = document.getElementById('container');
	var _vertexShader = document.getElementById('vertexShader').textContent;
	var _fragmentShader = document.getElementById('fragmentShader').textContent;
	var _world = new istWorld.Shader( _dom, _vertexShader, _fragmentShader, uniforms );
	var mouse = istWorld.mouse;

	//	start
	createStats();
	animate();

	//	events
	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'mousemove', onMouseMove, false );
	window.addEventListener( 'touchmove', onTouchMove, false );

	function createObject()
	{
		var geometry = new THREE.IcosahedronGeometry(80,1);
		var material = new THREE.MeshNormalMaterial({shading:THREE.NoShading});
		var mesh = new THREE.Mesh(geometry, material);
		return mesh;
	}

	//	method
	function createStats()
	{
		stats = new Stats();
		stats.domElement.style.position = 'fixed';
		stats.domElement.style.left = "0px";
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );
	}
	function animate()
	{
		stats.update();

		requestAnimationFrame( animate );
		loop();
	}
	function loop()
	{
		var _time = Date.now() * 0.001;
	}

	//	Handler
	function onWindowResize(e)
	{
		e.preventDefault();
		var _widh = window.innerWidth;
		var _height = window.innerHeight;
		_world.camera.aspect = _widh / _height;
		_world.camera.updateProjectionMatrix();
		_world.renderer.setSize( _widh, _height );

		istWorld.resolution = {x:_widh,y:_height};
		uniforms.resolution.value.x = _widh;
		uniforms.resolution.value.y = _height;
	}

	function onMouseMove(e)
	{
		e.preventDefault();
		mouse.x = e.pageX;
		mouse.y = e.pageY;

		uniforms.mouse.value.x = mouse.x;
		uniforms.mouse.value.y = window.innerHeight - mouse.y;
	}
	function onTouchMove(e)
	{
		e.preventDefault();
		mouse.x = e.touches[0].pageX;
		mouse.y = e.touches[0].pageY;

		uniforms.mouse.value.x = mouse.x;
		uniforms.mouse.value.y = window.innerHeight - mouse.y;
	}

});

/**
*	custom class
*	v 70
*	
*
*/
var istWorld;
(function(istWorld){

	//	Mouse
	istWorld.mouse = {x:window.innerWidth*0.5,y:window.innerHeight*0.5};

	//	resolution
	istWorld.resolution = {x:window.innerWidth,y:window.innerHeight}

	var three = (function(){
		function three( _dom )
		{
			//	props
			this.scene;
			this.camera;
			this.focus;
			this.renderer;

			//	init
			this.init3D( _dom );
			this.animate();
		}

		//	is enable WebGL?[boolean]
		three.isSupportedWebgl = function () {
            try {
                var canvas = document.createElement("canvas");
                return !!window["WebGLRenderingContext"] && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
            }
            catch (e) {
                return false;
            }
        };
        three.ZERO = new THREE.Vector3(0, 0, 0);
        //three.PROJECTOR = new THREE.Projector();

		three.prototype = {
			init3D	:	function( _dom )
			{
				var _width = window.innerWidth;
				var _height = window.innerHeight;

				//	カメラ
				this.camera = new THREE.PerspectiveCamera( 50, _width / _height, 0.1, 1500 );
				this.camera.position.z = 1000;

				//	カメラフォーカス	
				this.focus = new THREE.Vector3();
				this.focus.set( 0, 0, 0 );
				this.camera.lookAt( focus );

				//	SCENE
				this.scene = new THREE.Scene();
				this.scene.fog = new THREE.Fog( 0x181818, 1000, 1500 );

				//	renderer
				this.renderer = new THREE.WebGLRenderer( { antialias: false } );
				this.renderer.setClearColor( this.scene.fog.color, 1 );
				this.renderer.setSize( window.innerWidth, window.innerHeight );
				this.renderer.gammaInput = true;
				this.renderer.gammaOutput = true;
				this.renderer.autoClear = true;

				_dom.appendChild( this.renderer.domElement );
			},
			animate	:	function()
			{
				//requestAnimationFrame( this.animate );
				//this.render();
				var _this = this;
				setInterval(function(){
					_this.render();
				},1000/60);
			},
			render	:	function()
			{
				var _this = this;
				_this.camera.lookAt( _this.focus );
				_this.renderer.render( _this.scene, _this.camera );
			}
		}

		return three;
	})();
	istWorld.Three = three;

	var shader = (function(){
		function shader( _dom, _vid, _fid, _uniforms )
		{
			//	props
			this.scene;
			this.camera;
			this.focus;
			this.renderer;

			//
			this.vid = _vid;
			this.fid = _fid;

			_uniforms = _uniforms||{}
			this.uniforms = _uniforms;

			if( !this.uniforms.time )
			{
				this.uniforms.time = { type: "f", value: 1.0 }
			}

			//	init
			this.init3D( _dom );
			this.createScreen();
			this.animate();

		}

		shader.prototype = {
			init3D	:	function( _dom )
			{
				var _width = window.innerWidth;
				var _height = window.innerHeight;

				//	カメラ
				this.camera = new THREE.PerspectiveCamera( 50, _width / _height, 1, 1500 );
				this.camera.position.z = 1;

				//	カメラフォーカス	
				this.focus = new THREE.Vector3();
				this.focus.set( 0, 0, 0 );
				this.camera.lookAt( focus );

				//	SCENE
				this.scene = new THREE.Scene();
				this.scene.fog = new THREE.Fog( 0x181818, 1000, 1500 );

				//	renderer
				this.renderer = new THREE.WebGLRenderer( { antialias: false } );
				this.renderer.setClearColor( this.scene.fog.color, 1 );
				this.renderer.setSize( window.innerWidth, window.innerHeight );
				this.renderer.gammaInput = true;
				this.renderer.gammaOutput = true;

				_dom.appendChild( this.renderer.domElement );
			},
			createScreen	:	function()
			{
				var geometry = new THREE.PlaneBufferGeometry( 2, 2 );
				var material = new THREE.ShaderMaterial({
					uniforms: this.uniforms,
					vertexShader: this.vid,
					fragmentShader: this.fid
					//vertexShader: document.getElementById( this.vid ).textContent,
					//fragmentShader: document.getElementById( this.fid ).textContent
				} );

				var mesh = new THREE.Mesh( geometry, material );
				this.scene.add( mesh );
			},
			animate	:	function()
			{
				//requestAnimationFrame( this.animate );
				//this.render();
				var _this = this;
				setInterval(function(){
					_this.render();
					_this.uniforms.time.value += 0.05;
				},1000/60);
			},
			render	:	function()
			{
				var _this = this;
				_this.camera.lookAt( _this.focus );
				_this.renderer.render( _this.scene, _this.camera );
			}
		}
		return shader;
	})();
	istWorld.Shader = shader;
})(istWorld||(istWorld={}));
</script>
</body>
</html>