<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS, SHADER">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #FFF;
}
#container{
	width: 100%;
	height: 100%;
}
canvas{
	zoom: 0.5;
	float: left;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="../js/jquery-2.1.1.min.js"></script>
<script src="../js/Tweener.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/three.min.js"></script><!--/ v70 -->
<script id="vertexShader" type="x-shader/x-vertex">
void main( void ) 
{
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
void main( void ) 
{
	vec2 p = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
	vec3 c = vec3( 0.0, 0, 0 );
	float amplitude = 0.10; 
	float glowT = sin(time) * 0.5 + 0.5;
	float glowFactor = mix( 0.15, 0.35, glowT );
	c += vec3(0.02, 0.03, 0.13) * ( glowFactor * abs( 1.0 / sin(p.x + sin( p.y + time ) * amplitude ) ));
	c += vec3(0.02, 0.10, 0.03) * ( glowFactor * abs( 1.0 / sin(p.x + sin( p.y + time+1.00 ) * amplitude+0.1 ) ));
	c += vec3(0.13, 0.02, 0.03) * ( glowFactor * abs( 1.0 / sin(p.x + sin( p.y + time+2.00 ) * amplitude+0.2 ) ));
	
	gl_FragColor = vec4( c, 1.0 );
}
</script>

<script id="vertexShader2" type="x-shader/x-vertex">
void main( void ) 
{
	gl_Position = vec4( position, 1.0 );

}
</script>
<script id="fragmentShader2" type="x-shader/x-fragment">
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
void main(void)
{
	vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
	uv.x *=  resolution.x / resolution.y;
	
    // background	 
	vec3 color = vec3(0.8 + 0.2*uv.y);

    // bubbles	
	for( int i=0; i<40; i++ )
	{
        // bubble seeds
		float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;
		float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );
		float pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;
		
        // buble size, position and color
		float rad = 0.1 + .4*siz;
		vec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+.02*time*(0.2+0.8*siz),1.0));
		float dis = length( uv - pos );
		vec3  col = mix( vec3(0.5,0.3,0.0), vec3(0.1,0.4,0.4), 0.5+0.5*sin(float(i)*1.1+1.0));
		//    col+= 8.0*smoothstep( rad*0.95, rad, dis );
		
        // render
		float f = length(uv-pos)/rad;
		f = sqrt(clamp(.50-f*f,.0,1.0));
		color -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;
	}

    // vigneting	
	color *= sqrt(1.5-0.3*length(uv));

	gl_FragColor = vec4(color,1.0);
}
</script>
<script id="vertexShader3" type="x-shader/x-vertex">
void main( void ) 
{
	gl_Position = vec4( position, 1.0 );

}
</script>
<script id="fragmentShader3" type="x-shader/x-fragment">
//	http://glslsandbox.com/e#19335.0	
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){
	sy=sy*2.;
	y=y+sqrt(abs(y)/1.3)*2.; //was black below 'horizon'
	x=x/3.;
   float xx=x+sin(t*fx)*sx;
   float yy=y+cos(t*fy)*sy;
   return (1.0/sqrt(xx*xx+yy*yy)/y)*0.6;
}

void main( void ) {

   vec2 p=(gl_FragCoord.xy/resolution.x)*2.0-vec2(1.0,resolution.y/resolution.x);

   p=p*2.0;
   
   float x=p.x;
   float y=p.y;

   float a=
       makePoint(x,y,3.3,2.9,0.3,0.3,time);
   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,time);
   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,time);
   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time);
   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,time);
   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,time);
   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,time);
   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,time);
   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,time);   
   
   float b=
       makePoint(x,y,1.2,1.9,0.3,0.3,time);
   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);
   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);
   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);
   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);
   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);
   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);
   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);
   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);

   float c=
       makePoint(x,y,3.7,0.3,0.3,0.3,time);
   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);
   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);
   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);
   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);
   c=c+makePoint(x,y,0.3,0.3,0.4,0.4,time);
   c=c+makePoint(x,y,1.4,0.8,0.4,0.5,time);
   c=c+makePoint(x,y,0.2,0.6,0.6,0.3,time);
   c=c+makePoint(x,y,1.3,0.5,0.5,0.4,time);
   
   vec3 d=vec3(a,b,c)/20.0;
   
   gl_FragColor = vec4(d.x,d.y,d.z,1.0);
}

</script>
<script type="text/javascript">
window.addEventListener("load", function (){

	//	uniforms
	var uniforms = {
		time: { type: "f", value: 1.0 },
		resolution: { type: "v2", value: new THREE.Vector2() },
		mouse: { type: "v2", value: new THREE.Vector2() }
	};
	uniforms.time.value = 0.0;
	uniforms.resolution.value.x = window.innerWidth;
	uniforms.resolution.value.y = window.innerHeight;
	uniforms.mouse.value.x = 0;
	uniforms.mouse.value.y = 0;

	//	world
	var _dom = document.getElementById('container');
	var _vertexShader = document.getElementById('vertexShader').textContent;
	var _fragmentShader = document.getElementById('fragmentShader').textContent;
	var _worldShader = new istWorld.Shader( _dom, _vertexShader, _fragmentShader, uniforms );
	var _world = new istWorld.Three( _dom );
	var mouse = istWorld.mouse;

	//	
	_world.scene.add( createObject() )
	_world.scene.add( new THREE.AmbientLight( 0x181818 ) );
	var light = new THREE.DirectionalLight( 0x999999 );
	light.position.set( 1, 1, 1 );
	light.intensity = 1;
	_world.scene.add( light );

	_world.scene.fog.near = 1000;


	var _vertexShader2 = document.getElementById('vertexShader2').textContent;
	var _fragmentShader2 = document.getElementById('fragmentShader2').textContent;
	var _worldShader2 = new istWorld.Shader( _dom, _vertexShader2, _fragmentShader2, uniforms );

	var _vertexShader3 = document.getElementById('vertexShader3').textContent;
	var _fragmentShader3 = document.getElementById('fragmentShader3').textContent;
	var _worldShader3 = new istWorld.Shader( _dom, _vertexShader3, _fragmentShader3, uniforms );

	//	start
	createStats();
	animate();

	//	events
	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'mousemove', onMouseMove, false );
	window.addEventListener( 'touchmove', onTouchMove, false );

	function createObject()
	{
		var geometry = new THREE.IcosahedronGeometry(80,1);
		var material = new THREE.MeshNormalMaterial({shading:THREE.NoShading});
		var mesh = new THREE.Mesh(geometry, material);
		return mesh;
	}

	//	method
	function createStats()
	{
		stats = new Stats();
		stats.domElement.style.position = 'fixed';
		stats.domElement.style.left = "0px";
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );
	}
	function animate()
	{
		stats.update();

		requestAnimationFrame( animate );
		loop();
	}
	function loop()
	{
		var _time = Date.now() * 0.001;
	}

	//	Handler
	function onWindowResize(e)
	{
		console.log(this)
		e.preventDefault();
		var _widh = window.innerWidth;
		var _height = window.innerHeight;
		_world.camera.aspect = _widh / _height;
		_world.camera.updateProjectionMatrix();
		_world.renderer.setSize( _widh, _height );

		_worldShader.camera.aspect = _widh / _height;
		_worldShader.camera.updateProjectionMatrix();
		_worldShader.renderer.setSize( _widh, _height );

		_worldShader2.camera.aspect = _widh / _height;
		_worldShader2.camera.updateProjectionMatrix();
		_worldShader2.renderer.setSize( _widh, _height );

		_worldShader3.camera.aspect = _widh / _height;
		_worldShader3.camera.updateProjectionMatrix();
		_worldShader3.renderer.setSize( _widh, _height );


		istWorld.resolution = {x:_widh,y:_height};

		uniforms.resolution.value.x = _widh;
		uniforms.resolution.value.y = _height;
	}

	function onMouseMove(e)
	{
		e.preventDefault();
		mouse.x = e.pageX;
		mouse.y = e.pageY;

		uniforms.mouse.value.x = mouse.x;
		uniforms.mouse.value.y = mouse.y;
	}
	function onTouchMove(e)
	{
		e.preventDefault();
		mouse.x = e.touches[0].pageX;
		mouse.y = e.touches[0].pageY;

		uniforms.mouse.value.x = mouse.x;
		uniforms.mouse.value.y = mouse.y;
	}

});

/**
*	custom class
*	v 70
*	
*
*/
var istWorld;
(function(istWorld){

	//	Mouse
	istWorld.mouse = {x:window.innerWidth*0.5,y:window.innerHeight*0.5};

	//	resolution
	istWorld.resolution = {x:window.innerWidth,y:window.innerHeight}

	var three = (function(){
		function three( _dom )
		{
			//	props
			this.scene;
			this.camera;
			this.focus;
			this.renderer;

			//	init
			this.init3D( _dom );
			this.animate();
		}

		//	is enable WebGL?[boolean]
		three.isSupportedWebgl = function () {
            try {
                var canvas = document.createElement("canvas");
                return !!window["WebGLRenderingContext"] && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
            }
            catch (e) {
                return false;
            }
        };
        three.ZERO = new THREE.Vector3(0, 0, 0);
        //three.PROJECTOR = new THREE.Projector();

		three.prototype = {
			init3D	:	function( _dom )
			{
				var _width = window.innerWidth;
				var _height = window.innerHeight;

				//	カメラ
				this.camera = new THREE.PerspectiveCamera( 50, _width / _height, 0.1, 1500 );
				this.camera.position.z = 1000;

				//	カメラフォーカス	
				this.focus = new THREE.Vector3();
				this.focus.set( 0, 0, 0 );
				this.camera.lookAt( focus );

				//	SCENE
				this.scene = new THREE.Scene();
				this.scene.fog = new THREE.Fog( 0x181818, 1000, 1500 );

				//	renderer
				this.renderer = new THREE.WebGLRenderer( { antialias: false } );
				this.renderer.setClearColor( this.scene.fog.color, 1 );
				this.renderer.setSize( window.innerWidth, window.innerHeight );
				this.renderer.gammaInput = true;
				this.renderer.gammaOutput = true;

				_dom.appendChild( this.renderer.domElement );
			},
			animate	:	function()
			{
				//requestAnimationFrame( this.animate );
				//this.render();
				var _this = this;
				setInterval(function(){
					_this.render();
				},1000/60);
			},
			render	:	function()
			{
				var _this = this;
				_this.camera.lookAt( _this.focus );
				_this.renderer.render( _this.scene, _this.camera );
			}
		}

		return three;
	})();
	istWorld.Three = three;

	var shader = (function(){
		function shader( _dom, _vid, _fid, _uniforms )
		{
			//	props
			this.scene;
			this.camera;
			this.focus;
			this.renderer;

			//
			this.vid = _vid;
			this.fid = _fid;

			_uniforms = _uniforms||{}
			this.uniforms = _uniforms;

			if( !this.uniforms.time )
			{
				this.uniforms.time = { type: "f", value: 1.0 }
			}

			//	init
			this.init3D( _dom );
			this.createScreen();
			this.animate();

		}

		shader.prototype = {
			init3D	:	function( _dom )
			{
				var _width = window.innerWidth;
				var _height = window.innerHeight;

				//	カメラ
				this.camera = new THREE.PerspectiveCamera( 50, _width / _height, 1, 1500 );
				this.camera.position.z = 1;

				//	カメラフォーカス	
				this.focus = new THREE.Vector3();
				this.focus.set( 0, 0, 0 );
				this.camera.lookAt( focus );

				//	SCENE
				this.scene = new THREE.Scene();
				this.scene.fog = new THREE.Fog( 0x181818, 1000, 1500 );

				//	renderer
				this.renderer = new THREE.WebGLRenderer( { antialias: false } );
				this.renderer.setClearColor( this.scene.fog.color, 1 );
				this.renderer.setSize( window.innerWidth, window.innerHeight );
				this.renderer.gammaInput = true;
				this.renderer.gammaOutput = true;

				_dom.appendChild( this.renderer.domElement );
			},
			createScreen	:	function()
			{
				var geometry = new THREE.PlaneBufferGeometry( 2, 2 );
				var material = new THREE.ShaderMaterial({
					uniforms: this.uniforms,
					vertexShader: this.vid,
					fragmentShader: this.fid
					//vertexShader: document.getElementById( this.vid ).textContent,
					//fragmentShader: document.getElementById( this.fid ).textContent
				} );

				var mesh = new THREE.Mesh( geometry, material );
				this.scene.add( mesh );
			},
			animate	:	function()
			{
				//requestAnimationFrame( this.animate );
				//this.render();
				var _this = this;
				setInterval(function(){
					_this.render();
					_this.uniforms.time.value += 0.05;
				},1000/60);
			},
			render	:	function()
			{
				var _this = this;
				_this.camera.lookAt( _this.focus );
				_this.renderer.render( _this.scene, _this.camera );
			}
		}
		return shader;
	})();
	istWorld.Shader = shader;
})(istWorld||(istWorld={}));
</script>
</body>
</html>