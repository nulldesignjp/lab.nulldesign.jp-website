<!doctype>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="BufferGeometry">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
}
#container{
	width: 100%;
	height: 100%;
}
#counter{
	position: fixed;
	left: 32;
	top: 32;
	color: #FFF;
	font-family: Arial;
	z-index: 100;
}
</style>
</head>
<body>
<p id="counter"></p>
<div id="container"></div>
<script src="../js/three.min.js"></script>
<script type="text/javascript">
(function(){
	var container
	var camera
	var scene
	var renderer
	var mesh

	init();
	//animate();

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


	function init()
	{
		//	器
		container = document.getElementById('container');

		//	カメラ
		var _width = window.innerWidth;
		var _height = window.innerHeight;
		camera = new THREE.PerspectiveCamera( 27, _width / _height, 1, 3500 );
		camera.position.z = 2750;

		//	シーン
		//	http://threejs.org/docs/#Reference/Scenes/Scene
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

		scene.add( new THREE.AmbientLight( 0x444444 ) );
		scene.add( new THREE.AmbientLight( 0xCCCCCC ) );



		//	geometry
		//	http://threejs.org/docs/#Reference/Core/BufferGeometry

		//	BufferGeometry
		//	静的な3Dコンテンツを作り、表示する事に向いている
		//	インタラクティブな操作ではない

		var geometry = new THREE.BufferGeometry();

		//	pointlist
		var vertexPositions = [ 
			[-400.0, -400.0,  400.0],
			[ 400.0, -400.0,  400.0],
			[ 400.0,  400.0,  400.0],

			[ 400.0,  400.0,  -400.0],
			[-400.0,  400.0,  -400.0],
			[-400.0, -400.0,  -400.0]
		];

		vertexPositions = [];
		_plist = []

		var __z = 200;
		for( var i = 0; i < 6; i++ )
		{
			var __z = Math.floor( Math.random() * 400 - 200 );
			var _r = 1200;
			var _rad0 = ( i + 0 ) * 60 / 180 * Math.PI;
			var _rad1 = ( i + 1 ) * 60 / 180 * Math.PI;
			var _rad2 = ( i + 2 ) * 60 / 180 * Math.PI;
			//_plist[i] = [ [ 0, 0, 0 ], [ Math.cos( _rad1 ) * _r, Math.sin( _rad1 ) * _r, 0 ], [ Math.cos( _rad2 ) * _r, Math.sin( _rad2 ) * _r, 0 ] ];
			_plist[i] = getTriangle(0, 0, __z, Math.cos( _rad1 ) * _r, Math.sin( _rad1 ) * _r, __z, Math.cos( _rad2 ) * _r, Math.sin( _rad2 ) * _r, __z );
		}

		//setT();

		var _intervaKey = setInterval( function(){

			document.getElementById('counter').innerHTML = _plist.length;

			if( _plist.length )
			{
				var _l = _plist.shift();
				var len = _l.length;
				if( len == 4 )
				{
					//	saiki
					_plist.push( getTriangle( _l[0][0][0],_l[0][0][1],_l[0][0][2],_l[0][1][0],_l[0][1][1],_l[0][1][2],_l[0][2][0],_l[0][2][1],_l[0][2][2] ) )
					_plist.push( getTriangle( _l[1][0][0],_l[1][0][1],_l[1][0][2],_l[1][1][0],_l[1][1][1],_l[1][1][2],_l[1][2][0],_l[1][2][1],_l[1][2][2] ) )
					_plist.push( getTriangle( _l[2][0][0],_l[2][0][1],_l[2][0][2],_l[2][1][0],_l[2][1][1],_l[2][1][2],_l[2][2][0],_l[2][2][1],_l[2][2][2] ) )
					_plist.push( getTriangle( _l[3][0][0],_l[3][0][1],_l[3][0][2],_l[3][1][0],_l[3][1][1],_l[3][1][2],_l[3][2][0],_l[3][2][1],_l[3][2][2] ) )

				} else if( len == 3 ) {

					//	static
					vertexPositions.push( [ _l[0][0],_l[0][1],_l[0][2] ] );
					vertexPositions.push( [ _l[1][0],_l[1][1],_l[1][2] ] );
					vertexPositions.push( [ _l[2][0],_l[2][1],_l[2][2] ] );
				}

				//setT();
			} else {
				clearInterval( _intervaKey )
				_doit();
				animate();
				document.getElementById('counter').innerHTML = 'HACKist Argo';
			}

		},1000/60)

		function setT()
		{
			if( _plist.length )
			{
				var _l = _plist.shift();
				var len = _l.length;
				if( len == 4 )
				{
					//	saiki
					_plist.push( getTriangle( _l[0][0][0],_l[0][0][1],_l[0][0][2],_l[0][1][0],_l[0][1][1],_l[0][1][2],_l[0][2][0],_l[0][2][1],_l[0][2][2] ) )
					_plist.push( getTriangle( _l[1][0][0],_l[1][0][1],_l[1][0][2],_l[1][1][0],_l[1][1][1],_l[1][1][2],_l[1][2][0],_l[1][2][1],_l[1][2][2] ) )
					_plist.push( getTriangle( _l[2][0][0],_l[2][0][1],_l[2][0][2],_l[2][1][0],_l[2][1][1],_l[2][1][2],_l[2][2][0],_l[2][2][1],_l[2][2][2] ) )
					_plist.push( getTriangle( _l[3][0][0],_l[3][0][1],_l[3][0][2],_l[3][1][0],_l[3][1][1],_l[3][1][2],_l[3][2][0],_l[3][2][1],_l[3][2][2] ) )

				} else if( len == 3 ) {

					//	static
					vertexPositions.push( [ _l[0][0],_l[0][1],_l[0][2] ] );
					vertexPositions.push( [ _l[1][0],_l[1][1],_l[1][2] ] );
					vertexPositions.push( [ _l[2][0],_l[2][1],_l[2][2] ] );
				}

				setT();
			} else {
				_doit();
			}
		}


		function _doit()
		{
			var indices = new Uint16Array( vertexPositions.length );
			var normals = new Float32Array( vertexPositions.length * 3 );
			var colors = new Float32Array( vertexPositions.length * 3 );
			var positions = new Float32Array( vertexPositions.length * 3 );

			var color = new THREE.Color();

			var pA = new THREE.Vector3();
			var pB = new THREE.Vector3();
			var pC = new THREE.Vector3();

			var cb = new THREE.Vector3();
			var ab = new THREE.Vector3();

			for ( var i = 0; i < vertexPositions.length; i++ )
			{
				//	直線リストに
				positions[ i*3 + 0 ] = vertexPositions[i][0];
				positions[ i*3 + 1 ] = vertexPositions[i][1];
				positions[ i*3 + 2 ] = vertexPositions[i][2];

				//	インデックスはそのまま
				indices[i] = i;
			}


			for ( var i = 0; i < positions.length; i += 9 )
			{
				var ax = positions[ i * 9 + 0 ];
				var ay = positions[ i * 9 + 1 ];
				var az = positions[ i * 9 + 2 ];
				var bx = positions[ i * 9 + 3 ];
				var by = positions[ i * 9 + 4 ];
				var bz = positions[ i * 9 + 5 ];
				var cx = positions[ i * 9 + 6 ];
				var cy = positions[ i * 9 + 7 ];
				var cz = positions[ i * 9 + 8 ];

				//	p[oint to face]
				pA.set( ax, ay, az );
				pB.set( bx, by, bz );
				pC.set( cx, cy, cz );

				cb.subVectors( pC, pB );
				ab.subVectors( pA, pB );
				cb.cross( ab );

				cb.normalize();

				var nx = cb.x;
				var ny = cb.y;
				var nz = cb.z;

				normals[ i + 0 ] = nx;
				normals[ i + 1 ] = ny;
				normals[ i + 2 ] = nz;

				normals[ i + 3 ] = nx;
				normals[ i + 4 ] = ny;
				normals[ i + 5 ] = nz;

				normals[ i + 6 ] = nx;
				normals[ i + 7 ] = ny;
				normals[ i + 8 ] = nz;

				//	setColor
				color.setRGB( Math.random(), Math.random(), Math.random() );

				//	point0
				color.setHSL( Math.random(), 1.0, 0.5 );
				colors[ i + 0 ] = color.r;
				colors[ i + 1 ] = color.g;
				colors[ i + 2 ] = color.b;

				//	point1
				color.setHSL( Math.random(), 1.0, 0.5 );
				colors[ i + 3 ] = color.r;
				colors[ i + 4 ] = color.g;
				colors[ i + 5 ] = color.b;

				//	point2
				color.setHSL( Math.random(), 1.0, 0.5 );
				colors[ i + 6 ] = color.r;
				colors[ i + 7 ] = color.g;
				colors[ i + 8 ] = color.b;
			}

			geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
			geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );


			//	material
			//	http://threejs.org/docs/#Reference/Materials/MeshBasicMaterial
			//var material = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide } );
			var material = new THREE.MeshPhongMaterial( {
						color: 0xFFFFFF, ambient: 0xCCCCCC, specular: 0xffffff, shininess: 250,
						side: THREE.DoubleSide, vertexColors: THREE.VertexColors
					} );
			mesh = new THREE.Mesh( geometry, material );

			scene.add( mesh );

			//	renderer
			renderer = new THREE.WebGLRenderer( { antialias: false } );
			renderer.setClearColor( scene.fog.color, 1 );
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			container.appendChild( renderer.domElement );

		}

	}

	function animate()
	{
		requestAnimationFrame( animate );
		render();
	}

	function render()
	{
		var time = Date.now() * 0.0001;
		mesh.rotation.x = time * 0.25;
		mesh.rotation.y = time * 0.5;
		mesh.rotation.x = Math.sin( time * 0.25 ) * 3;
		mesh.rotation.y = Math.cos( time * 0.5 ) * 3;

		renderer.render( scene, camera );

		camera.position.z = 2750 + Math.sin( time ) * 400;
	}

	function getTriangle( _x0, _y0, _z0, _x1, _y1, _z1, _x2, _y2, _z2 )
	{
		var _dx = _x0 - _x1;
		var _dy = _y0 - _y1;
		var _dz = _z0 - _z1;
		var _len = Math.sqrt( _dx * _dx + _dy * _dy + _dz * _dz )
		var _isEnable = _len > 50;

		_z0 = Math.floor( Math.random() * 100 - 50 ) + 100;
		_z1 = _z2 = _z0;

		if( Math.random() < 0.5 && _isEnable )
		{
			var _ax = ( _x0 + _x1 ) * 0.5;
			var _ay = ( _y0 + _y1 ) * 0.5;
			var _az = ( _z0 + _z1 ) * 0.5;

			var _bx = ( _x1 + _x2 ) * 0.5;
			var _by = ( _y1 + _y2 ) * 0.5;
			var _bz = ( _z1 + _z2 ) * 0.5;

			var _cx = ( _x0 + _x2 ) * 0.5;
			var _cy = ( _y0 + _y2 ) * 0.5;
			var _cz = ( _z0 + _z2 ) * 0.5;

			return	[
					[[_x0,_y0,_z0],[_ax,_ay,_az],[_cx,_cy,_cz]],
					[[_ax,_ay,_az],[_x1,_y1,_z1],[_bx,_by,_bz]],
					[[_bx,_by,_bz],[_x2,_y2,_z2],[_cx,_cy,_cz]],
					[[_ax,_ay,_az],[_bx,_by,_bz],[_cx,_cy,_cz]]
					]
		}

		return [ [ _x0, _y0, _z0],[ _x1, _y1, _z1 ],[ _x2, _y2, _z2 ] ];
	}

})();
</script>
</body>
</html>