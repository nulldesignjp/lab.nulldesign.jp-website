<!doctype>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="BufferGeometry">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
}
#container{
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="../js/three.min.js"></script>
<script type="text/javascript">
(function(){
	var container
	var camera
	var scene
	var renderer
	var mesh

	init();
	animate();

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


	function init()
	{
		//	器
		container = document.getElementById('container');

		//	カメラ
		var _width = window.innerWidth;
		var _height = window.innerHeight;
		camera = new THREE.PerspectiveCamera( 27, _width / _height, 1, 3500 );
		camera.position.z = 2750;

		//	シーン
		//	http://threejs.org/docs/#Reference/Scenes/Scene
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

		scene.add( new THREE.AmbientLight( 0x444444 ) );



		//	geometry
		//	http://threejs.org/docs/#Reference/Core/BufferGeometry

		//	BufferGeometry
		//	静的な3Dコンテンツを作り、表示する事に向いている
		//	インタラクティブな操作ではない

		var geometry = new THREE.BufferGeometry();

		//	pointlist
		var vertexPositions = [ 
			[-200.0, -200.0,  200.0],
			[ 200.0, -200.0,  200.0],
			[ 200.0,  200.0,  200.0],

			[ 200.0,  200.0,  200.0],
			[-200.0,  200.0,  200.0],
			[-200.0, -200.0,  200.0]
		];

		//	vertexPositions to single array
		var vertices = new Float32Array( vertexPositions.length * 3 );
		for ( var i = 0; i < vertexPositions.length; i++ )
		{
			vertices[ i*3 + 0 ] = vertexPositions[i][0];
			vertices[ i*3 + 1 ] = vertexPositions[i][1];
			vertices[ i*3 + 2 ] = vertexPositions[i][2];
		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

		//	material
		//	http://threejs.org/docs/#Reference/Materials/MeshBasicMaterial
		var material = new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } );
		mesh = new THREE.Mesh( geometry, material );

		scene.add( mesh );

		//	renderer
		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setClearColor( scene.fog.color, 1 );
		renderer.setSize( window.innerWidth, window.innerHeight );

		renderer.gammaInput = true;
		renderer.gammaOutput = true;

		container.appendChild( renderer.domElement );

		/*
		geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
		*/
		//var colors = new Float32Array( triangles * 3 * 3 );
		//var color = new THREE.Color();


	}

	function animate()
	{
		requestAnimationFrame( animate );
		render();
	}

	function render()
	{
		var time = Date.now() * 0.001;
		mesh.rotation.x = time * 0.25;
		mesh.rotation.y = time * 0.5;
		renderer.render( scene, camera );
	}

})();
</script>
</body>
</html>