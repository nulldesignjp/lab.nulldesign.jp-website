<!doctype>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="BufferGeometry">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
}
#container{
	width: 100%;
	height: 100%;
}
#counter{
	position: fixed;
	left: 32;
	top: 32;
	color: #FFF;
	font-family: Arial;
	z-index: 100;
}
</style>
</head>
<body>
<p id="counter"></p>
<div id="container"></div>
<script src="../js/three.min.js"></script>
<script type="text/javascript">
(function(){
	var forceField
	var forceFieldCtx
	var container
	var camera
	var scene
	var renderer
	var mesh

	//init();
	//animate();
	getSource();

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function getSource()
	{
		var _img = new Image();
		_img.onload = function()
		{
			forceField = document.createElement('CANVAS');
			forceFieldCtx = forceField.getContext('2d');

			forceField.width = this.width;
			forceField.height = this.height;

			forceFieldCtx.drawImage( this, 0, 0 );

			init();

		}
		_img.src = 'perlinNoise.png';
	}


	function init()
	{
		//	器
		container = document.getElementById('container');

		//	カメラ
		var _width = window.innerWidth;
		var _height = window.innerHeight;
		camera = new THREE.PerspectiveCamera( 27, _width / _height, 1, 3500 );
		camera.position.z = 2750;
		camera.position.y = 800;

		var _focus = new THREE.Vector3();
		_focus.set( 0, -300, 0 );
		camera.lookAt( _focus );

		//	シーン
		//	http://threejs.org/docs/#Reference/Scenes/Scene
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

		scene.add( new THREE.AmbientLight( 0x444444 ) );
		scene.add( new THREE.AmbientLight( 0xCCCCCC ) );



		//	geometry
		//	http://threejs.org/docs/#Reference/Core/BufferGeometry

		var _fieldList = [];
		var _grid = 10;
		for( var i = 0; i < forceField.width / _grid; i++ )
		{
			_fieldList[i] = [];
			for( var j = 0; j < forceField.height / _grid; j++ )
			{
				var _zoom = 5;
				var _x = i * _grid;
				var _y = j * _grid;
				var _h = 80 * _zoom;
				var _c = forceFieldCtx.getImageData( _x, _y, 1, 1).data;
				var _r = _c[0] / 255;
				var _g = _c[1] / 255;
				var _b = _c[2] / 255;

				_fieldList[i][j] = [ _x * _zoom - forceField.width * 0.5 * _zoom, _r * _h - 300, _y * _zoom - forceField.height * 0.5 * _zoom ];
			}
		}

		var geometry = new THREE.BufferGeometry();

		//	pointlist
		var vertexPositions = [];


		for( var i = 0; i < forceField.width / _grid - 1; i++ )
		{
			for( var j = 0; j < forceField.height / _grid - 1; j++ )
			{
				
				var _p0 = _fieldList[i+0][j+0];
				var _p1 = _fieldList[i+1][j+0];
				var _p2 = _fieldList[i+1][j+1];
				var _p3 = _fieldList[i+0][j+1];

				vertexPositions.push( _p0 );
				vertexPositions.push( _p1 );
				vertexPositions.push( _p2 );

				vertexPositions.push( _p0 );
				vertexPositions.push( _p2 );
				vertexPositions.push( _p3 );

			}
		}

		
		_doit();
		animate();

		function _doit()
		{
			var indices = new Uint16Array( vertexPositions.length );
			var normals = new Float32Array( vertexPositions.length * 3 );
			var colors = new Float32Array( vertexPositions.length * 3 );
			var positions = new Float32Array( vertexPositions.length * 3 );

			var color = new THREE.Color();

			var pA = new THREE.Vector3();
			var pB = new THREE.Vector3();
			var pC = new THREE.Vector3();

			var cb = new THREE.Vector3();
			var ab = new THREE.Vector3();

			for ( var i = 0; i < vertexPositions.length; i++ )
			{
				//	直線リストに
				positions[ i*3 + 0 ] = vertexPositions[i][0];
				positions[ i*3 + 1 ] = vertexPositions[i][1];
				positions[ i*3 + 2 ] = vertexPositions[i][2];

				//	インデックスはそのまま
				indices[i] = i;
			}


			for ( var i = 0; i < positions.length; i += 9 )
			{
				var ax = positions[ i * 9 + 0 ];
				var ay = positions[ i * 9 + 1 ];
				var az = positions[ i * 9 + 2 ];
				var bx = positions[ i * 9 + 3 ];
				var by = positions[ i * 9 + 4 ];
				var bz = positions[ i * 9 + 5 ];
				var cx = positions[ i * 9 + 6 ];
				var cy = positions[ i * 9 + 7 ];
				var cz = positions[ i * 9 + 8 ];

				//	p[oint to face]
				pA.set( ax, ay, az );
				pB.set( bx, by, bz );
				pC.set( cx, cy, cz );

				cb.subVectors( pC, pB );
				ab.subVectors( pA, pB );
				cb.cross( ab );

				cb.normalize();

				var nx = cb.x;
				var ny = cb.y;
				var nz = cb.z;

				normals[ i + 0 ] = nx;
				normals[ i + 1 ] = ny;
				normals[ i + 2 ] = nz;

				normals[ i + 3 ] = nx;
				normals[ i + 4 ] = ny;
				normals[ i + 5 ] = nz;

				normals[ i + 6 ] = nx;
				normals[ i + 7 ] = ny;
				normals[ i + 8 ] = nz;

				//	setColor
				color.setRGB( 0.9,0.9,0.9 );

				//	point0
				color.setHSL( Math.random(), 1.0, 0.92 );
				colors[ i + 0 ] = color.r;
				colors[ i + 1 ] = color.g;
				colors[ i + 2 ] = color.b;

				//	point1
				color.setHSL( Math.random(), 1.0, 0.92 );
				colors[ i + 3 ] = color.r;
				colors[ i + 4 ] = color.g;
				colors[ i + 5 ] = color.b;

				//	point2
				color.setHSL( Math.random(), 1.0, 0.92 );
				colors[ i + 6 ] = color.r;
				colors[ i + 7 ] = color.g;
				colors[ i + 8 ] = color.b;
			}

			geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
			geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );


			//	material
			//	http://threejs.org/docs/#Reference/Materials/MeshBasicMaterial
			//var material = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide } );
			var material = new THREE.MeshPhongMaterial( {
						color: 0xFFFFFF, ambient: 0xCCCCCC, specular: 0x0000FF, shininess: 300,
						side: THREE.DoubleSide, vertexColors: THREE.VertexColors, shading: THREE.SmoothShading
					} );
			mesh = new THREE.Mesh( geometry, material );

			scene.add( mesh );

			//	renderer
			renderer = new THREE.WebGLRenderer( { antialias: false } );
			renderer.setClearColor( scene.fog.color, 1 );
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			container.appendChild( renderer.domElement );

		}

	}

	function animate()
	{
		requestAnimationFrame( animate );
		render();
	}

	function render()
	{
		var time = Date.now() * 0.0001;
		//mesh.rotation.x = time * 0.25;
		mesh.rotation.y = time * 0.5;

		renderer.render( scene, camera );

		//camera.position.z = 1750 + Math.sin( time ) * 250;

	}

	function getTriangle( _x0, _y0, _z0, _x1, _y1, _z1, _x2, _y2, _z2 )
	{
		var _dx = _x0 - _x1;
		var _dy = _y0 - _y1;
		var _dz = _z0 - _z1;
		var _len = Math.sqrt( _dx * _dx + _dy * _dy + _dz * _dz )
		var _isEnable = _len > 50;

		_z0 = Math.floor( Math.random() * 100 - 50 ) + 100;
		_z1 = _z2 = _z0;

		if( Math.random() < 0.5 && _isEnable )
		{
			var _ax = ( _x0 + _x1 ) * 0.5;
			var _ay = ( _y0 + _y1 ) * 0.5;
			var _az = ( _z0 + _z1 ) * 0.5;

			var _bx = ( _x1 + _x2 ) * 0.5;
			var _by = ( _y1 + _y2 ) * 0.5;
			var _bz = ( _z1 + _z2 ) * 0.5;

			var _cx = ( _x0 + _x2 ) * 0.5;
			var _cy = ( _y0 + _y2 ) * 0.5;
			var _cz = ( _z0 + _z2 ) * 0.5;

			return	[
					[[_x0,_y0,_z0],[_ax,_ay,_az],[_cx,_cy,_cz]],
					[[_ax,_ay,_az],[_x1,_y1,_z1],[_bx,_by,_bz]],
					[[_bx,_by,_bz],[_x2,_y2,_z2],[_cx,_cy,_cz]],
					[[_ax,_ay,_az],[_bx,_by,_bz],[_cx,_cy,_cz]]
					]
		}

		return [ [ _x0, _y0, _z0],[ _x1, _y1, _z1 ],[ _x2, _y2, _z2 ] ];
	}

})();
</script>
</body>
</html>