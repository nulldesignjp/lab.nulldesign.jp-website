<!doctype>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="BufferGeometry">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
}
#container{
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<div id="container"></div>
<script src="../js/three.min.js"></script>
<script type="text/javascript">
(function(){
	var container
	var camera
	var scene
	var renderer
	var mesh

	init();
	animate();

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


	function init()
	{
		//	器
		container = document.getElementById('container');

		//	カメラ
		var _width = window.innerWidth;
		var _height = window.innerHeight;
		camera = new THREE.PerspectiveCamera( 27, _width / _height, 1, 3500 );
		camera.position.z = 2750;

		//	シーン
		//	http://threejs.org/docs/#Reference/Scenes/Scene
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

		scene.add( new THREE.AmbientLight( 0x444444 ) );



		//	geometry
		//	http://threejs.org/docs/#Reference/Core/BufferGeometry

		//	BufferGeometry
		//	静的な3Dコンテンツを作り、表示する事に向いている
		//	インタラクティブな操作ではない

		var geometry = new THREE.BufferGeometry();

		//	pointlist
		var vertexPositions = [ 
			[-400.0, -400.0,  400.0],
			[ 400.0, -400.0,  400.0],
			[ 400.0,  400.0,  400.0],

			[ 400.0,  400.0,  -400.0],
			[-400.0,  400.0,  -400.0],
			[-400.0, -400.0,  -400.0]
		];

		for( var i = 0; i < 3; i++ )
		{
			var _r = 300;
			var _rad0 = i * 120 / 180 * Math.PI;
			var _rad1 = ( i + 1 ) * 120 / 180 * Math.PI;
			vertexPositions[ i * 3 + 0 ] = [ 0, 0, 0 ];
			vertexPositions[ i * 3 + 1 ] = [ Math.cos( _rad0 ) * _r, Math.sin( _rad0 ) * _r, _r ];
			vertexPositions[ i * 3 + 2 ] = [ Math.cos( _rad1 ) * _r, Math.sin( _rad1 ) * _r, _r ];
		}


		/*
		for( var i = 0; i < 1000; i++ )
		{
			vertexPositions.push([Math.random() * 1000-500,Math.random() * 1000-500,Math.random() * 1000-500]);
		}
		*/

		var indices = new Uint16Array( vertexPositions.length );
		var normals = new Float32Array( vertexPositions.length * 3 );
		var colors = new Float32Array( vertexPositions.length * 3 );
		var positions = new Float32Array( vertexPositions.length * 3 );

		var color = new THREE.Color();

		var pA = new THREE.Vector3();
		var pB = new THREE.Vector3();
		var pC = new THREE.Vector3();

		var cb = new THREE.Vector3();
		var ab = new THREE.Vector3();

		for ( var i = 0; i < vertexPositions.length; i++ )
		{
			//	直線リストに
			positions[ i*3 + 0 ] = vertexPositions[i][0];
			positions[ i*3 + 1 ] = vertexPositions[i][1];
			positions[ i*3 + 2 ] = vertexPositions[i][2];

			//	インデックスはそのまま
			indices[i] = i;
		}


		for ( var i = 0; i < positions.length; i += 9 )
		{
			var ax = positions[ i * 9 + 0 ];
			var ay = positions[ i * 9 + 1 ];
			var az = positions[ i * 9 + 2 ];
			var bx = positions[ i * 9 + 3 ];
			var by = positions[ i * 9 + 4 ];
			var bz = positions[ i * 9 + 5 ];
			var cx = positions[ i * 9 + 6 ];
			var cy = positions[ i * 9 + 7 ];
			var cz = positions[ i * 9 + 8 ];

			//	p[oint to face]
			pA.set( ax, ay, az );
			pB.set( bx, by, bz );
			pC.set( cx, cy, cz );

			cb.subVectors( pC, pB );
			ab.subVectors( pA, pB );
			cb.cross( ab );

			cb.normalize();

			var nx = cb.x;
			var ny = cb.y;
			var nz = cb.z;

			normals[ i + 0 ] = nx;
			normals[ i + 1 ] = ny;
			normals[ i + 2 ] = nz;

			normals[ i + 3 ] = nx;
			normals[ i + 4 ] = ny;
			normals[ i + 5 ] = nz;

			normals[ i + 6 ] = nx;
			normals[ i + 7 ] = ny;
			normals[ i + 8 ] = nz;

			//	setColor
			color.setRGB( Math.random(), Math.random(), Math.random() );

			//	point0
			colors[ i + 0 ] = color.r;
			colors[ i + 1 ] = color.g;
			colors[ i + 2 ] = color.b;

			//	point1
			colors[ i + 3 ] = color.r;
			colors[ i + 4 ] = color.g;
			colors[ i + 5 ] = color.b;

			//	point2
			colors[ i + 6 ] = color.r;
			colors[ i + 7 ] = color.g;
			colors[ i + 8 ] = color.b;
		}

		geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );


		//	material
		//	http://threejs.org/docs/#Reference/Materials/MeshBasicMaterial
		//var material = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide } );
		var material = new THREE.MeshPhongMaterial( {
					color: 0xFFFFFF, ambient: 0xCCCCCC, specular: 0xffffff, shininess: 250,
					side: THREE.DoubleSide, vertexColors: THREE.VertexColors
				} );
		mesh = new THREE.Mesh( geometry, material );

		scene.add( mesh );

		//	renderer
		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setClearColor( scene.fog.color, 1 );
		renderer.setSize( window.innerWidth, window.innerHeight );

		renderer.gammaInput = true;
		renderer.gammaOutput = true;

		container.appendChild( renderer.domElement );


	}

	function animate()
	{
		requestAnimationFrame( animate );
		render();
	}

	function render()
	{
		var time = Date.now() * 0.001;
		mesh.rotation.x = time * 0.25;
		mesh.rotation.y = time * 0.5;
		renderer.render( scene, camera );

		camera.position.z = 2750 + Math.sin( time ) * 400;
	}

})();
</script>
</body>
</html>