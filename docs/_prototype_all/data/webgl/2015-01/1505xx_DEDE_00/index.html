<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="sandbox, particle, mouse, with Audio.">
<meta name="description" content="">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{margin:0;padding:0;background:#000;color:#FFF;font-size:12px;font-family:Georgia;}
#container{width:100%;height:100%;}
canvas{position:fixed;left:0;top:0;}
h1,p{margin:0;padding:0;line-height:1;position:fixed;z-index:100;font-size:1em;}
h1{left:16px;top:64px;font-weight:normal;}
p{left:16px;bottom:32px;}
</style>
</head>
<body>
<h1>DEDEMOUSE</h1>
<div id="container"></div>
<script src="../js/jquery-2.1.3.min.js"></script>
<script src="../js/Detector.js"></script>
<script src="../js/perlin-noise-simplex.js"></script>
<script src="../js/r71/three.min.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/THREE.ConvexGeometry.js"></script>
<script src="world3d.js"></script>
<script type="x-shader/x-vertex" id="vertexshader">
uniform float volume;
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main()
{
    vec3 p = position;
    p.z = position.z * volume;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );
    gl_PointSize = 6.0 * abs( normalize( p ).z );
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
uniform float volume;
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
void main()
{
    gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
</script>
<script type="text/javascript">
(function(){

    //  stats
    var stats;
    createStats();

    //  perlinNoise
    var _perlinNoise = new SimplexNoise();
    var _value = _perlinNoise.noise( 0, 0 );

    var _world = new world3d.three( document.getElementById('container') );
    _world.camera.position.set( 0, 1, 250 );
    var _group = new THREE.Group();
    _world.scene.add( _group );

    var _l0 = new THREE.AmbientLight( 0x181818 );
    _world.scene.add( _l0 );

    var _l1 = new THREE.DirectionalLight( 0xCCCCCC, 1.0 );
    _l1.position.set( 1, 1, 1 );
    _world.scene.add( _l1 );

    var _l2 = new THREE.SpotLight( 0xCCCCCC );
    _l2.position.set( 100, 1000, 100 );
    // spotLight.castShadow = true;

    // spotLight.shadowMapWidth = 1024;
    // spotLight.shadowMapHeight = 1024;

    // spotLight.shadowCameraNear = 500;
    // spotLight.shadowCameraFar = 4000;
    // spotLight.shadowCameraFov = 30;
    _world.scene.add( _l2 );

    var geometry = new THREE.Geometry();
    var lenX = 256;
    var lenY = 256;
    var _grid = 10.0;
    for( var i = 0; i < lenX; i++ )
    {
        for( var j = 0; j < lenY; j++ )
        {
            var _x = ( i - lenX*0.5 ) * _grid;
            var _y = ( j - lenY*0.5 ) * _grid;
            var _z = _perlinNoise.noise( ( _x + 10000 ) * 0.001, ( _y + 10000 ) * 0.001 );
            var _v3 = new THREE.Vector3( _x, _y, _z * 200 );
            geometry.vertices.push( _v3 );
        }
    }

    var uniforms = {
        volume: { type: "f", value: 0.0 },
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() },
        mouse: { type: "v2", value: new THREE.Vector2() }
    };
    uniforms.time.value = 0.0;
    uniforms.resolution.value.x = window.innerWidth;
    uniforms.resolution.value.y = window.innerHeight;
    uniforms.mouse.value.x = 0;
    uniforms.mouse.value.y = 0;
    uniforms.volume.value = 0.0;

    var _vertexShader = document.getElementById('vertexshader').textContent;
    var _fragmentShader = document.getElementById('fragmentshader').textContent;
    var material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: _vertexShader,
        fragmentShader: _fragmentShader
    });

    //var material = new THREE.PointCloudMaterial({color: 0xFFFFFF,size: 2});
    var _mesh = new THREE.PointCloud( geometry, material );
    _mesh.rotation.x = - Math.PI * 0.5;
    _group.add( _mesh );


    // var material = new THREE.MeshLambertMaterial({shading: THREE.FlatShading,color: 0x33333,wireframe:true});
    // for( var i = 0; i < 24; i++ )
    // {
    //     var vertices = [];
    //     for( var j = 0; j < 32; j++ )
    //     {
    //         vertices.push( new THREE.Vector3(Math.random()*60-30,Math.random()*60-30,Math.random()*60-30))
    //     }
    //     var geometry = new THREE.ConvexGeometry( vertices )
    //     var __mesh = new THREE.Mesh( geometry, material );
    //     __mesh.position.x = Math.random() * 2000 - 1000;
    //     __mesh.position.y = Math.random() * 1000 - 500;
    //     __mesh.position.z = Math.random() * 1000 - 500;
    //     _group.add( __mesh );
    // }

            window.addEventListener('mousemove', function (e) {
                world3d.mouse.x = e.pageX;
                world3d.mouse.y = e.pageY;
                uniforms.mouse.value.x = world3d.mouse.x / window.innerWidth;
                uniforms.mouse.value.y = (window.innerHeight - world3d.mouse.y) / window.innerHeight;
                e.preventDefault();
            }, false);
            window.addEventListener('touchmove', function (e) {
                world3d.mouse.x = e.touches[0].pageX;
                world3d.mouse.y = e.touches[0].pageY;
                uniforms.mouse.value.x = world3d.mouse.x / window.innerWidth;
                uniforms.mouse.value.y = (window.innerHeight - world3d.mouse.y) / window.innerHeight;
                e.preventDefault();
            }, false);
            window.addEventListener('mousedown', function (e) {
                uniforms.volume.value += 0.8;

                _perlinNoise = new SimplexNoise();
                var len = _mesh.geometry.vertices.length;
                var _position = Math.random() * 5000 + 5000;
                var _scale = Math.random() * 0.0005 + 0.00075;
                while( len )
                {
                    len --;
                    var _x = _mesh.geometry.vertices[len].x;
                    var _y = _mesh.geometry.vertices[len].y;
                    var _z = _perlinNoise.noise( ( _x + _position ) * _scale, ( _y + _position ) * _scale ) * 200;
                    _mesh.geometry.vertices[len].z = _z;
                }
                _mesh.geometry.verticesNeedUpdate = true;
                geometry.verticesNeedUpdate = true;
                e.preventDefault();
            }, false);

    _world.engine = function(){
        stats.update();

        uniforms.volume.value *= 0.86;
    }

    setInterval(function(){
        _world.focus.x = Math.sin( Date.now() * 0.0001 ) * 100;
    },1000/60);


    setUpAudioEvents();

    function setUpAudioEvents()
    {
        var _size = 2048 * 0.25;
        var audioContext = new AudioContext();

        //フィルター
        var filter = audioContext.createBiquadFilter();
        filter.type = 0;
        filter.frequency.value = 440;
        //analyserオブジェクトの生成
        var analyser = audioContext.createAnalyser();
        analyser.fftSize = _size;

        initMic();

        function initMic(){  
            var audioObj = {"audio":true};

            //エラー処理
            var errBack = function(e){
                console.log("Web Audio error:",e.code);
            };

            
            //WebAudioリクエスト成功時に呼び出されるコールバック関数
            function gotStream(stream){
                //streamからAudioNodeを作成
                var mediaStreamSource = audioContext.createMediaStreamSource(stream);

                mediaStreamSource.connect(filter);

                filter.connect(analyser);
                //出力Nodeのdestinationに接続
                analyser.connect(audioContext.destination);
                //mediaStreamSource.connect(audioContext.destination);

                Loop();
            }
            //マイクの有無を調べる
            if(navigator.webkitGetUserMedia){
                //マイク使って良いか聞いてくる
                navigator.webkitGetUserMedia(audioObj,gotStream,errBack);
            }else{
                console.log("マイクデバイスがありません");
            }
        }

        function Loop(){
            //符号なし8bitArrayを生成
            //var data = new Uint8Array( analyser.frequencyBinCount );
            //周波数データ
            //analyser.getByteFrequencyData(data);

            var sum;
            var average;
            var bar_width;
            var scaled_average;
            var num_bars = 60;
            var data = new Uint8Array(_size);
            var spectrums = new Uint8Array(analyser.frequencyBinCount);  // Array size is 1024 (half of FFT size)
            analyser.getByteFrequencyData(spectrums);

            var _max = 1.0;
            var len = spectrums.length;
            for (var i = 0; i < len; i++)
            {
                if( spectrums[i] != 0 )
                {
                    _max = i;
                };
            }

            var _value = 0;
            for( var i = 0; i < _max; i++ )
            {
                _value += spectrums[i];
            }

            uniforms.volume.value += _value / _max / 255;


    $('h1').text('DEDEMOUSE' + ' - ' + uniforms.volume.value );;

            //ループ
            requestAnimationFrame(Loop);
        }
    }




    function createStats()
    {
        stats = new Stats();
        stats.domElement.style.position = 'fixed';
        stats.domElement.style.left = "0px";
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = '100';
        document.getElementById('container').appendChild( stats.domElement );
    }

    var _scale = screen.width / ( 1280 * 3 );
    var _top = Math.floor( ( screen.height - 1024 * _scale ) * 0.5 );

    window.moveTo( 0, _top );
    window.resizeTo( 1280 * 3  * _scale, 1024 * _scale );
})();
</script>
</body>
</html>