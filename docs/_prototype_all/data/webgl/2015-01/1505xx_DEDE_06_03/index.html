<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS">
<title>DE DE MOUSE + HACKist</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
	color: #FFF;
	font-size: 12px;
	font-family: Arial;
}
#container{
	width: 100%;
	height: 100%;
}

h1,p{
	margin: 0;
	padding: 0;
	line-height: 1;
	position: fixed;
	z-index: 100;
	font-size: 1em;
}
h1{
	left: 32px;
	top: 32px;
}
p{
	left: 32px;
	bottom: 32px;
}
</style>
</head>
<body>
<h1>Galaxy00</h1>
<div id="container"></div>
<p>&copy; nulldesign.jp</p>
<script src="../js/jquery-2.1.3.min.js"></script>
<script src="../js/Detector.js"></script>
<script src="../js/perlin-noise-simplex.js"></script>
<script src="../js/r71/three.min.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/THREE.ConvexGeometry.js"></script>
<script src="world3d.js"></script>

<script type="x-shader/x-vertex" id="vertexshader">
void main()
{
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
highp float Rand(vec2 co)
{
    highp float a = 1552.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

float iAspectRatio = 3.0;

float Noise(vec2 UV, float Seed, vec2 Frequency){
	vec2 PerlinR = vec2(UV.x, UV.y) * vec2(Frequency);
	highp vec2 Perlin1Pos = vec2(floor(PerlinR.x), floor(PerlinR.y));
	
	float RandX0 = (Perlin1Pos.x+(Perlin1Pos.y)*Seed);
	float RandX1 = ((Perlin1Pos.x+1.0)+(Perlin1Pos.y)*Seed);
	float RandX2 = (Perlin1Pos.x+(Perlin1Pos.y+1.0)*Seed);
	float RandX3 = ((Perlin1Pos.x+1.0)+(Perlin1Pos.y+1.0)*Seed);
	
	float Perlin0Val = Rand(vec2(RandX0,RandX0*0.1224));
	float Perlin1Val = Rand(vec2(RandX1,RandX1*0.1224));
	float Perlin2Val = Rand(vec2(RandX2,RandX2*0.1224));
	float Perlin3Val = Rand(vec2(RandX3,RandX3*0.1224));
	
	vec2 Perc = (sin(((PerlinR - Perlin1Pos) * vec2(3.1415926)) - vec2(1.570796)) * vec2(0.5)) + vec2(0.5);
	
	float Val0to2 = (Perlin0Val*(1.0-Perc.y)) + (Perlin2Val*Perc.y); 
	float Val1to3 = (Perlin1Val*(1.0-Perc.y)) + (Perlin3Val*Perc.y); 
	
	return (Val0to2 * (1.0-Perc.x)) + (Val1to3 * Perc.x);	
}
float PerlinNoise1(vec2 UV, float Seed){
	float RetVal = 0.0;
	RetVal += Noise(UV, Seed * 1.2, vec2(2.0)) * 0.5;
	RetVal += Noise(UV, Seed * 1.4, vec2(5.0)) * 0.25;
	RetVal += Noise(UV, Seed * 1.1, vec2(10.0)) * 0.125;
	RetVal += Noise(UV, Seed * 1.5, vec2(24.0)) * 0.0625;
	RetVal += Noise(UV, Seed * 1.2, vec2(54.0)) * 0.03125;
	RetVal += Noise(UV, Seed * 1.9, vec2(128.0)) * 0.025625;
	return RetVal;
}
float PerlinNoise2(vec2 UV, float Seed){
	float RetVal = 0.0;
	RetVal += Noise(UV, Seed * 1.2, vec2(6.0)) * 0.5;
	RetVal += Noise(UV, Seed * 1.4, vec2(12.0)) * 0.25;
	RetVal += Noise(UV, Seed * 1.1, vec2(24.0)) * 0.125;
	RetVal += Noise(UV, Seed * 1.5, vec2(40.0)) * 0.0625;
	RetVal += Noise(UV, Seed * 1.2, vec2(80.0)) * 0.03125;
	RetVal += Noise(UV, Seed * 1.3, vec2(158.0)) * 0.025625;
	return RetVal;
}
void main(){
	vec2 UV = gl_FragCoord.xy / resolution.xy;

	vec2 TimeOffset = vec2(time * .02, time * 0.002);
	vec2 TempVec2A = TimeOffset;
	vec2 TempVec2B = vec2(0.0);
	vec2 TempVec2C = vec2(0.0);
	vec3 TempVec3A = vec3(0.0);
	TempVec2C.x = pow(abs(.8 - PerlinNoise1(UV + TempVec2A, 1.32143)), 2.0);
	TempVec3A = vec3(TempVec2C.x) * vec3(0.25, 0.4, 0.5);
	TempVec2C.x = pow(abs((.9 - PerlinNoise2(UV + (TempVec2A * vec2(1.15)), 12.523)) * TempVec2C.x), 1.1);
	TempVec3A += vec3(TempVec2C.x) * vec3(.0, .1, .8);
	
	vec4 RetVal = vec4(.0,.0,.0,100);	
	TempVec2C.x = Rand(vec2(UV.x, UV.y));
	TempVec2C.y = Rand(vec2(UV.y, UV.x));
	highp float PowIn = ((sin(((time+10.0)*TempVec2C.x*2.7))*.8)+0.5); 
	RetVal.xyz = max(vec3(TempVec2C.x * pow(TempVec2C.y, 20.0) * pow(PowIn, 1.0) * .4), vec3(0.0)); 
	RetVal.xyz += TempVec3A;

	gl_FragColor = RetVal;
}
</script>

<script type="text/javascript">

// var _scale = screen.width / ( 1280 * 3 );
// var _top = Math.floor( ( screen.height - 1024 * _scale ) * 0.5 );
// window.moveTo( 0, _top );
// window.resizeTo( 1280 * 3  * _scale, 1024 * _scale );

(function(){

    var uniforms = {
        volume: { type: "f", value: 0.0 },
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() },
        mouse: { type: "v2", value: new THREE.Vector2() }
    };
    uniforms.time.value = 0.0;
    uniforms.resolution.value.x = window.innerWidth;
    uniforms.resolution.value.y = window.innerHeight;
    uniforms.mouse.value.x = 0;
    uniforms.mouse.value.y = 0;
    uniforms.volume.value = 0.0;

    var _vertexShader = document.getElementById('vertexshader').textContent;
    var _fragmentShader = document.getElementById('fragmentshader').textContent;

    var _width = window.innerWidth;
    var _height = window.innerHeight;
    var _dom = document.getElementById('container');

    var camera = new THREE.OrthographicCamera(-_width * 0.5, _width * 0.5, _height * 0.5, -_height * 0.5, 0.1, 2000);
    //camera = new THREE.PerspectiveCamera( 35, _width / _height, 0.1, 2000 );
    camera.position.z = 1000;
    var focus = new THREE.Vector3();
    focus.set(0, 0, 0);
    camera.lookAt(focus);

    var scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 1200, 1500);
	//	renderer
	renderer = new THREE.WebGLRenderer({ antialias: false });
	renderer.setClearColor(scene.fog.color, 1);
	renderer.setSize(_width,_height);
	_dom.appendChild(renderer.domElement);

    var geometry = new THREE.PlaneGeometry(_width, _height, 1, 1 );
    var material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: _vertexShader,
        fragmentShader: _fragmentShader
    });
    var mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    setInterval(function(){
    	uniforms.time.value += 0.05;
        camera.lookAt(focus);
        renderer.render(scene,camera);
    },1000/60);

})();
</script>
</body>
</html>