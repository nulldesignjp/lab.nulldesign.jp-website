<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="sandbox, particle, mouse, with Audio.">
<meta name="description" content="">
<title>webgl sample</title>
<style>
html,body{height:100%;overflow:hidden;}
body{margin:0;padding:0;background:#000;color:#FFF;font-size:12px;font-family:Georgia;}
#container{width:100%;height:100%;}
canvas{position:fixed;left:0;top:0;}
h1,p{margin:0;padding:0;line-height:1;position:fixed;z-index:100;font-size:1em;}
h1{left:16px;top:64px;font-weight:normal;}
p{left:16px;bottom:32px;}
</style>
</head>
<body>
<h1>DEDEMOUSE</h1>
<div id="container"></div>
<script src="../js/jquery-2.1.3.min.js"></script>
<script src="../js/Detector.js"></script>
<script src="../js/perlin-noise-simplex.js"></script>
<script src="../js/r71/three.min.js"></script>
<script src="../js/stats.min.js"></script>
<script src="../js/THREE.ConvexGeometry.js"></script>
<script src="world3d.js"></script>
<script type="x-shader/x-vertex" id="vertexshader">
uniform float volume;
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

varying vec3 vUv;

const int   oct  = 8;
const float per  = 0.5;
const float PI   = 3.1415926;
const float cCorners = 1.0 / 16.0;
const float cSides   = 1.0 / 8.0;
const float cCenter  = 1.0 / 4.0;

// 補間関数
float interpolate(float a, float b, float x){
    float f = (1.0 - cos(x * PI)) * 0.5;
    return a * (1.0 - f) + b * f;
}

// 乱数生成
float rnd(vec2 p){
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

// 補間乱数
float irnd(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec4 v = vec4(rnd(vec2(i.x,       i.y      )),
                  rnd(vec2(i.x + 1.0, i.y      )),
                  rnd(vec2(i.x,       i.y + 1.0)),
                  rnd(vec2(i.x + 1.0, i.y + 1.0)));
    return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);
}

// ノイズ生成
float noise(vec2 p){
    float t = 0.0;
    for(int i = 0; i < oct; i++){
        float freq = pow(2.0, float(i));
        float amp  = pow(per, float(oct - i));
        t += irnd(vec2(p.x / freq, p.y / freq)) * amp;
    }
    return t;
}

// シームレスノイズ生成
float snoise(vec2 p, vec2 q, vec2 r){
    return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +
           noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +
           noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +
           noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);
}


void main()
{
    vec3 p = position;

    float scale = 0.2;
    //float f = rnd( vec2( position.x, position.y ) );
    float z = ( noise( vec2( position.x * scale + time * 100.0, position.y * scale + time * 40.0 ) ) - 0.5 ) * 2.0;// () +- 1.0

    p.z = 100.0 * z * volume;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );

    float dotScale = ( 1600.0 - length( position.xy ) ) / 1600.0;
    dotScale = dotScale<0.0?0.0:dotScale;
    gl_PointSize = 3.0 * dotScale;

    vUv = p;
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
uniform float volume;
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

varying vec3 vUv;

void main()
{
    //vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec2 uv = normalize( vUv.xy );
    vec4 col = vec4( uv,1.0,1.0);

    gl_FragColor = col * volume;
    //gl_FragColor *= volume;
    gl_FragColor /= vUv.z;
}
</script>
<script type="text/javascript">
(function(){

    //  stats
    var stats;
    createStats();

    //  perlinNoise
    var _perlinNoise = new SimplexNoise();
    var _value = _perlinNoise.noise( 0, 0 );

    var _world = new world3d.three( document.getElementById('container') );
    _world.camera.position.set( 0, 40, 250 );
    _world.focus.y = _world.camera.position.y;
    var _group = new THREE.Group();
    _world.scene.add( _group );

    var _l0 = new THREE.AmbientLight( 0x181818 );
    _world.scene.add( _l0 );

    var _l1 = new THREE.DirectionalLight( 0xCCCCCC, 1.0 );
    _l1.position.set( 1, 1, 1 );
    _world.scene.add( _l1 );

    var _l2 = new THREE.SpotLight( 0xCCCCCC );
    _l2.position.set( 100, 1000, 100 );
    // spotLight.castShadow = true;

    // spotLight.shadowMapWidth = 1024;
    // spotLight.shadowMapHeight = 1024;

    // spotLight.shadowCameraNear = 500;
    // spotLight.shadowCameraFar = 4000;
    // spotLight.shadowCameraFov = 30;
    _world.scene.add( _l2 );

    var _pow = Math.floor( Math.random() * 3 ) + 4;
    var _div = Math.pow( 2, _pow );

    var geometry = new THREE.PlaneGeometry(1920,1920,_div,_div);

    var uniforms = {
        volume: { type: "f", value: 0.0 },
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() },
        mouse: { type: "v2", value: new THREE.Vector2() }
    };
    uniforms.time.value = 0.0;
    uniforms.resolution.value.x = window.innerWidth;
    uniforms.resolution.value.y = window.innerHeight;
    uniforms.mouse.value.x = 0;
    uniforms.mouse.value.y = 0;
    uniforms.volume.value = 0.0;

    var _vertexShader = document.getElementById('vertexshader').textContent;
    var _fragmentShader = document.getElementById('fragmentshader').textContent;
    var material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: _vertexShader,
        fragmentShader: _fragmentShader,
        side: THREE.DoubleSide,
        wireframe:true,
        color: 0xFFFFFF
    });

    //var material = new THREE.PointCloudMaterial({color: 0xFFFFFF,size: 2});
    var _mesh = new THREE.Mesh( geometry, material );
    _mesh.rotation.x = Math.PI * 0.5;
    _group.add( _mesh );


    // var material = new THREE.MeshLambertMaterial({shading: THREE.FlatShading,color: 0x33333,wireframe:true});
    // for( var i = 0; i < 24; i++ )
    // {
    //     var vertices = [];
    //     for( var j = 0; j < 32; j++ )
    //     {
    //         vertices.push( new THREE.Vector3(Math.random()*60-30,Math.random()*60-30,Math.random()*60-30))
    //     }
    //     var geometry = new THREE.ConvexGeometry( vertices )
    //     var __mesh = new THREE.Mesh( geometry, material );
    //     __mesh.position.x = Math.random() * 2000 - 1000;
    //     __mesh.position.y = Math.random() * 1000 - 500;
    //     __mesh.position.z = Math.random() * 1000 - 500;
    //     _group.add( __mesh );
    // }

            window.addEventListener('mousemove', function (e) {
                world3d.mouse.x = e.pageX;
                world3d.mouse.y = e.pageY;
                uniforms.mouse.value.x = world3d.mouse.x / window.innerWidth;
                uniforms.mouse.value.y = (window.innerHeight - world3d.mouse.y) / window.innerHeight;
                e.preventDefault();
            }, false);
            window.addEventListener('touchmove', function (e) {
                world3d.mouse.x = e.touches[0].pageX;
                world3d.mouse.y = e.touches[0].pageY;
                uniforms.mouse.value.x = world3d.mouse.x / window.innerWidth;
                uniforms.mouse.value.y = (window.innerHeight - world3d.mouse.y) / window.innerHeight;
                e.preventDefault();
            }, false);
            window.addEventListener('mousedown', function (e) {
                uniforms.volume.value += 0.8;
                // _perlinNoise = new SimplexNoise();
                // var len = _mesh.geometry.vertices.length;
                // var _position = Math.random() * 5000 + 5000;
                // var _scale = Math.random() * 0.0005 + 0.00075;
                // while( len )
                // {
                //     len --;
                //     var _x = _mesh.geometry.vertices[len].x;
                //     var _y = _mesh.geometry.vertices[len].y;
                //     var _r = ( 1.0 - Math.random() * Math.random() ) * 1280;
                //     var _rad = Math.random() * Math.PI * 2;
                //     _x = Math.cos( _rad ) * _r;
                //     _y = Math.sin( _rad ) * _r;

                //     _mesh.geometry.vertices[len].x = _x;
                //     _mesh.geometry.vertices[len].y = _y;

                //     var _z = _perlinNoise.noise( ( _x + _position ) * _scale, ( _y + _position ) * _scale ) * 200;
                //     _mesh.geometry.vertices[len].z = _z;
                // }
                // _mesh.geometry.verticesNeedUpdate = true;
                e.preventDefault();
            }, false);

    _world.engine = function(){
        stats.update();
        uniforms.volume.value += ( 0 - uniforms.volume.value ) * 0.36;
    }

    setInterval(function(){

        uniforms.time.value += 0.01;
        _world.camera.position.x = Math.cos( Date.now() * 0.0001 ) * 100;
        _world.camera.position.z = Math.sin( Date.now() * 0.0001 ) * 100;


        _world.camera.position.y = 600;

    },1000/60);


    setUpAudioEvents();

    function setUpAudioEvents()
    {
        var _size = 2048 * 0.25;
        var audioContext = new AudioContext();

        //フィルター
        var filter = audioContext.createBiquadFilter();
        filter.type = 0;
        filter.frequency.value = 440;
        //analyserオブジェクトの生成
        var analyser = audioContext.createAnalyser();
        analyser.fftSize = _size;

        initMic();

        function initMic(){  
            var audioObj = {"audio":true};

            //エラー処理
            var errBack = function(e){
                console.log("Web Audio error:",e.code);
            };

            
            //WebAudioリクエスト成功時に呼び出されるコールバック関数
            function gotStream(stream){
                //streamからAudioNodeを作成
                var mediaStreamSource = audioContext.createMediaStreamSource(stream);

                mediaStreamSource.connect(filter);

                filter.connect(analyser);
                //出力Nodeのdestinationに接続
                analyser.connect(audioContext.destination);
                //mediaStreamSource.connect(audioContext.destination);

                Loop();
            }
            //マイクの有無を調べる
            if(navigator.webkitGetUserMedia){
                //マイク使って良いか聞いてくる
                navigator.webkitGetUserMedia(audioObj,gotStream,errBack);
            }else{
                console.log("マイクデバイスがありません");
            }
        }

        function Loop(){
            //符号なし8bitArrayを生成
            //var data = new Uint8Array( analyser.frequencyBinCount );
            //周波数データ
            //analyser.getByteFrequencyData(data);

            var sum;
            var average;
            var bar_width;
            var scaled_average;
            var num_bars = 60;
            var data = new Uint8Array(_size);
            var spectrums = new Uint8Array(analyser.frequencyBinCount);  // Array size is 1024 (half of FFT size)
            analyser.getByteFrequencyData(spectrums);

            var _max = 1.0;
            var len = spectrums.length;
            for (var i = 0; i < len; i++)
            {
                if( spectrums[i] != 0 )
                {
                    _max = i;
                };
            }

            var _value = 0;
            for( var i = 0; i < _max; i++ )
            {
                _value += spectrums[i];
            }

            uniforms.volume.value += _value / _max / 255;

            $('h1').text('DEDEMOUSE' + ' - ' + uniforms.volume.value );;

            //ループ
            requestAnimationFrame(Loop);

        }
    }

    function createStats()
    {
        stats = new Stats();
        stats.domElement.style.position = 'fixed';
        stats.domElement.style.left = "0px";
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = '100';
        document.getElementById('container').appendChild( stats.domElement );
    }

    var _scale = screen.width / ( 1280 * 3 );
    var _top = Math.floor( ( screen.height - 1024 * _scale ) * 0.5 );

    window.moveTo( 0, _top );
    window.resizeTo( 1280 * 3  * _scale, 1024 * _scale );
})();
</script>
</body>
</html>