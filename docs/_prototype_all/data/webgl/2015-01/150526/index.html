<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="shader, particle, 100000">
<meta name="description" content="">
<title>WebGL SAMPLE.</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
	color: #FFF;
	font-size: 12px;
	font-family: Arial;
}
#container{
	width: 100%;
	height: 100%;
}
</style>
<script type="x-shader/x-vertex" id="vertexshader">
const int   oct  = 8;
const float per  = 0.5;
const float PI   = 3.1415926;
const float cCorners = 1.0 / 16.0;
const float cSides   = 1.0 / 8.0;
const float cCenter  = 1.0 / 4.0;

// 補間関数
float interpolate(float a, float b, float x){
    float f = (1.0 - cos(x * PI)) * 0.5;
    return a * (1.0 - f) + b * f;
}

// 乱数生成
float rnd(vec2 p){
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

// 補間乱数
float irnd(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec4 v = vec4(rnd(vec2(i.x,       i.y      )),
                  rnd(vec2(i.x + 1.0, i.y      )),
                  rnd(vec2(i.x,       i.y + 1.0)),
                  rnd(vec2(i.x + 1.0, i.y + 1.0)));
    return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);
}

// ノイズ生成
float noise(vec2 p){
    float t = 0.0;
    for(int i = 0; i < oct; i++){
        float freq = pow(2.0, float(i));
        float amp  = pow(per, float(oct - i));
        t += irnd(vec2(p.x / freq, p.y / freq)) * amp;
    }
    return t;
}

// シームレスノイズ生成
float snoise(vec2 p, vec2 q, vec2 r){
    return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +
           noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +
           noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +
           noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);
}

uniform float time;
//uniform float scale;
//uniform float size;

attribute float size;
attribute vec3 customColor;

varying vec3 vColor;
void main()
{
    vec3 pos = position;
	vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
    //gl_PointSize = 1.0 * size;
    gl_PointSize = 1.0;
    vColor = customColor;

	gl_Position = projectionMatrix * mvPosition;
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
uniform vec3 color;
uniform sampler2D texture;
varying vec3 vColor;
void main()
{
	//gl_FragColor = vec4( vColor, 1.0 );
    //gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
    gl_FragColor = texture2D( texture, gl_PointCoord );

    gl_FragColor += vec4( 0.2, 0.6, 0.8, 0.1 );
}
</script>
</head>
<body>
<div id="container"></div>
<script src="jquery-2.1.3.min.js"></script>
<script src="three.min.js"></script>
<script src="THREE.ConvexGeometry.js"></script>
<script src="perlin-noise-simplex.js"></script>

<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/DotScreenShader.js"></script>
<script src="js/shaders/RGBShiftShader.js"></script>

<script src="js/shaders/DigitalGlitch.js"></script>

<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/GlitchPass.js"></script>

<script src="engine.js"></script>
</body>
</html>