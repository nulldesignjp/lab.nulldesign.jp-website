<!DOCTYPE HTML>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="robots" content="noindex,nofollow,noarchive">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="">
<title>audio [MIC]</title>
</head>
<body>
<div id="container">
<h1>WebAudioAPI</h1>
<p id="info"></p>
<p>周波数領域の波形データ (振幅スペクトル)</p>
<canvas id="canvas0">CANVAS非対応って話</canvas>
<p>周波数</p>
<canvas id="canvas1">CANVAS非対応って話</canvas>
<p>時間領域の波形描画</p>
<canvas id="canvas">CANVAS非対応って話</canvas>
<p>周波数領域の波形描画</p>
<canvas id="canvas2">CANVAS非対応って話</canvas>
<p>dB</p>
<canvas id="canvas3">CANVAS非対応って話</canvas>
<p>マイクから周波数取得(WebAudio)</p>
<canvas id="canvas4">CANVAS非対応って話</canvas>
<p>KOI ORIGINAL(WebAudio/意味不明)</p>
<canvas id="canvas5">CANVAS非対応って話</canvas>
<p>0 - 1に丸め込み</p>
<canvas id="canvas6">CANVAS非対応って話</canvas>
<p>0 - 1に丸め込み - 差分1</p>
<canvas id="canvas7">CANVAS非対応って話</canvas>

</div>
<script type="text/javascript">

(function(){

	var _canvas = document.getElementById('canvas');
	var _ctx = _canvas.getContext('2d');
	var _canvas0 = document.getElementById('canvas0');
	var _ctx0 = _canvas0.getContext('2d');
	var _canvas1 = document.getElementById('canvas1');
	var _ctx1 = _canvas1.getContext('2d');
	var _canvas2 = document.getElementById('canvas2');
	var _ctx2 = _canvas2.getContext('2d');
	var _canvas3 = document.getElementById('canvas3');
	var _ctx3 = _canvas3.getContext('2d');
	var _canvas4 = document.getElementById('canvas4');
	var _ctx4 = _canvas4.getContext('2d');
	var _canvas5 = document.getElementById('canvas5');
	var _ctx5 = _canvas5.getContext('2d');
	var _canvas6 = document.getElementById('canvas6');
	var _ctx6 = _canvas6.getContext('2d');
	var _canvas7 = document.getElementById('canvas7');
	var _ctx7 = _canvas7.getContext('2d');

	_canvas.width = 
	_canvas1.width = 
	_canvas2.width = 
	_canvas3.width = 
	_canvas4.width = 
	_canvas5.width = 
	_canvas6.width = 
	_canvas7.width = 
	_canvas0.width = window.innerWidth;

	//	WebAudioAPI
	//	http://curtaincall.weblike.jp/portfolio-web-sounder/webaudioapi-visualization/draw-wave
	window.AudioContext = window.AudioContext || window.webkitAudioContext;
	try
	{
		// Create the instance of AudioContext
		var context = new AudioContext();
	} catch (error) {
		alert(error.message + ' : Please use Chrome or Safari.');
		return;
	}

	initAudio();

	//	AUDIO API
	var _size = 2048;
	var audioContext
	var filter
	var analyser
	function initAudio()
	{
		audioContext = new AudioContext();

		//フィルター
		filter = audioContext.createBiquadFilter();
		filter.type = 0;
		filter.frequency.value = 440;
		//analyserオブジェクトの生成



		analyser = audioContext.createAnalyser();
		//	http://curtaincall.weblike.jp/portfolio-web-sounder/webaudioapi-visualization/demos/demo-03
		//	fftSize: 高速フーリエ変換のデータサイズ	2048
		//	frequencyBinCount: fftSizeプロパティの1 / 2の値
		//	minDecibels: getByteFrequencyDataメソッドで取得可能なデシベルの下限
		//	maxDecibels: getByteFrequencyDataメソッドで取得可能なデシベルの上限
		//	smoothingTimeConstant: 周波数領域の波形 (振幅スペクトル) 描画に関連するプパティ
		//	getByteTimeDomainData(array): 時間領域の波形データを取得するメソッド
		//	getByteFrequencyData(array): 周波数領域の波形データ (振幅スペクトル) を取得するメソッド
		//	getFloatFrequencyData(array): 周波数領域の波形データ (振幅スペクトル) をデシベル単位で取得するメソッド
		analyser.fftSize = 2048;

		analyser.minDecibels = -120;	//	0
		analyser.maxDecibels = -30;		//	255

		console.log(analyser )




		//
		var audioObj = {"audio":true};

		var errBack = function(e){
			console.log("Web Audio error:",e.code);
		};

		//WebAudioリクエスト成功時に呼び出されるコールバック関数
		function gotStream(stream)
		{
			//streamからAudioNodeを作成
			var mediaStreamSource = audioContext.createMediaStreamSource(stream);
			mediaStreamSource.connect(filter);

			filter.connect(analyser);
			//出力Nodeのdestinationに接続
			analyser.connect(audioContext.destination);
			//mediaStreamSource.connect(audioContext.destination);

			_nextStep();
		}

		//マイクの有無を調べる
		if(navigator.webkitGetUserMedia)
		{
			//マイク使って良いか聞いてくる
			navigator.webkitGetUserMedia(audioObj,gotStream,errBack);
		}else{
			console.log("マイクデバイスがありません");
		}
	}

	var period = 1 / context.sampleRate;

	// Frequency Resolution
	var fsDivN = context.sampleRate / analyser.fftSize;

	// This value is the number of samples during 500 Hz
	var n500Hz = Math.floor(500 / fsDivN);

	var _intervalKey;

	function _nextStep()
	{
		_intervalKey = setInterval(function(){

			var _w = _canvas0.width;
			var _h = _canvas0.height;
            var sum;
            var average;
            var bar_width;
            var scaled_average;
	        var num_bars = _w;

	        var data = new Uint8Array( analyser.fftSize );

	        //  CLEAR
	        _ctx0.beginPath();
	        _ctx0.clearRect(0, 0, _canvas0.width, _canvas0.height);

	        //  周波数領域の波形データ (振幅スペクトル) を取得するメソッド
	        analyser.getByteFrequencyData(data);
	        var bin_size = Math.floor(data.length / num_bars);
	        _ctx0.fillStyle = '#333333';
	        for (var i = 0; i < num_bars; i++ )
	        {
	            sum = 0;
	            for (var j = 0; j < bin_size; j++ )
	            {
	                sum += data[(i * bin_size) + j];
	            }
	            average = sum / bin_size;
	            bar_width = _w / num_bars;
	            scaled_average = (average / 256) * _h;
	            _ctx0.fillRect(i * bar_width, _h, bar_width - 2, - scaled_average);
	        }
	        _ctx0.fill();













			var array = new Uint8Array( analyser.fftSize );
			analyser.getByteTimeDomainData( array );

			//	波形データは, 0 ～ 255, つまり, 符号なし整数 (unsigned int) 1バイトの範囲で配列に格納されます. 振幅が1で考えると, 1が255, 0 (無音) が128, -1が0に対応しています. この値の関係に基づいて, Canvasに描画します.

			var _w = _canvas.width;
			var _h = _canvas.height;

			_ctx.beginPath();
			_ctx.clearRect( 0, 0, _w, _h );

			var len = array.length;
			for (var i = 0; i < len; i++ )
			{
				var x = ( i / len ) * _w;
				var y = ( 1 - ( array[i] / 255 ) ) * _h;

				if (i === 0)
				{
					_ctx.moveTo(x, y);
				} else {
					_ctx.lineTo(x, y);
				}

				//	drawTIME
				var sec  = i * period;             // index -> time
				var msec = sec * Math.pow(10, 3);  // sec -> msec

				// 5 msec ?
				if( (msec % 5) === 0)
				{
					var text = Math.round(msec) + ' msec';
					// Draw grid (X)
					_ctx.fillRect( x, 0, 1, _h);
					// Draw text (X)
					_ctx.fillText(text, x, _h);
				}
			}
			_ctx.moveTo(0, _h * 0.5);
			_ctx.lineTo(_w, _h * 0.5);
			_ctx.stroke();



			//	周波数領域の波形描画
			var spectrums = new Uint8Array( analyser.frequencyBinCount );
			analyser.getByteFrequencyData( spectrums );

			var _w = _canvas2.width;
			var _h = _canvas2.height;
			var len = spectrums.length;

			_ctx2.beginPath();
			_ctx2.clearRect( 0, 0, _w, _h );

			for (var i = 0; i < len; i++ )
			{
				var x = ( i / len ) * _w;
				var y = ( 1 - ( spectrums[i] / 255 ) ) * _h;

				if( i === 0 )
				{
					_ctx2.moveTo(x, y);
				} else {
					_ctx2.lineTo(x, y);
				}

				// 500 Hz ?
				if ((i % n500Hz) === 0)
				{
					var f    = Math.floor(500 * (i / n500Hz));  // index -> frequency
					var text = (f < 1000) ? (f + ' Hz') : ((f / 1000) + ' kHz');
					// Draw grid (X)
					_ctx2.fillRect(x, 0, 1, _h );
					// Draw text (X)
					_ctx2.fillText(text, x, _h );
		        }
			}
			_ctx2.stroke();















			// Get data for drawing spectrum (dB)
			var range = analyser.maxDecibels - analyser.minDecibels;  // 70 dB
			var spectrums = new Float32Array(analyser.frequencyBinCount);
			analyser.getFloatFrequencyData(spectrums);

			var _w = _canvas3.width;
			var _h = _canvas3.height;

			// Draw spectrum (dB)
			var paddingTop = 0;
			var paddingBottom = 0;
			var paddingLeft = 0;
			var paddingRight = 0;
            _ctx3.beginPath();
			_ctx3.clearRect( 0, 0, _w, _h );

			var len = spectrums.length;
 
			var range = analyser.maxDecibels - analyser.minDecibels;  // 70 dB
			var spectrums = new Float32Array(analyser.frequencyBinCount);
			analyser.getFloatFrequencyData(spectrums);
            for (var i = 0;i < len; i++) {
                var x = Math.floor((i / len) * _w) + paddingLeft;
                var y = Math.floor(-1 * ((spectrums[i] - analyser.maxDecibels) / range) * _h) + paddingTop;
 
                if (i === 0) {
                    _ctx3.moveTo(x, y);
                } else {
                    _ctx3.lineTo(x, y);
                }
 
                if (i % n500Hz === 0) {
                    var text = (500 * (i / n500Hz)) + ' Hz';  // index -> frequency
 
                    // Draw grid (X)
                    _ctx3.fillStyle = 'rgba(255, 0, 0, 1.0)';
                    _ctx3.fillRect(x, paddingTop, 1, _h);
 
                    // Draw text (X)
                    _ctx3.fillStyle = 'rgba(51, 51, 51, 1.0)';
                    _ctx3.font      = '12px "Times New Roman"';
                    _ctx3.fillText(text, (x - (_ctx3.measureText(text).width / 2)), (_h - 3));
                }
            }
 
            _ctx3.strokeStyle = 'rgba(0, 0, 255, 1.0)';
            _ctx3.lineWidth   = 2;
            _ctx3.lineCap     = 'round';
            _ctx3.lineJoin    = 'miter';
            _ctx3.stroke();
 
            // Draw grid and text (Y)
            for (var i = analyser.minDecibels; i <= analyser.maxDecibels; i += 10) {
                var gy = Math.floor(-1 * ((i - analyser.maxDecibels) / range) * _h) + paddingTop;
 
                // Draw grid (Y)
                _ctx3.fillStyle = 'rgba(255, 0, 0, 1.0)';
                _ctx3.fillRect(paddingLeft, gy, _w, 1);
 
                // Draw text (Y)
                _ctx3.fillStyle = 'rgba(51, 51, 51, 1.0)';
                _ctx3.font      = '12px "Times New Roman"';
                _ctx3.fillText((i + ' dB'), 3, gy);
            }







            //  時間領域の波形データを取得するメソッド
			var _w = _canvas1.width;
			var _h = _canvas1.height;
			_ctx1.clearRect( 0, 0, _w, _h );
            _ctx1.beginPath();
            _ctx1.strokeStyle = '#0000FF';
            var times = new Uint8Array( analyser.fftSize );
            analyser.getByteTimeDomainData(times);
            for (var i = 0, len = times.length; i < len; i++)
            {
                var x = (i / len) * _w;
                var y = ( 1 - ( times[i] / 255 ) ) * _h;

                if (i === 0) {
                    _ctx1.moveTo(x, y);
                } else {
                    _ctx1.lineTo(x, y);
                }
            }
            _ctx1.stroke();



            //符号なし8bitArrayを生成
            var data = new Uint8Array(analyser.frequencyBinCount);

            //周波数データ

		//	getByteTimeDomainData(array): 時間領域の波形データを取得するメソッド
		//	getByteFrequencyData(array): 周波数領域の波形データ (振幅スペクトル) を取得するメソッド
		//	getFloatFrequencyData(array): 周波数領域の波形データ (振幅スペクトル) をデシベル単位で取得するメソッド
            analyser.getByteFrequencyData(data);
			var _w = _canvas4.width;
			var _h = _canvas4.height;
			_ctx4.clearRect( 0, 0, _w, _h );
            _ctx4.beginPath();

            var len = data.length;
            for(var i = 0; i < len; ++i)
            {
            	//上部の描画
            	_ctx4.fillRect(i*3, 0, 3, data[i] / 255 * _h );
            }

            _ctx4.fill();




            //符号なし8bitArrayを生成
			var _w = _canvas5.width;
			var _h = _canvas5.height;
			_ctx5.clearRect( 0, 0, _w, _h );
            _ctx5.beginPath();
            var data = new Float32Array( analyser.frequencyBinCount );
            analyser.getFloatFrequencyData( data );

            var len = data.length;
            for(var i = 0; i < len; ++i)
            {
            	//上部の描画
            	_ctx5.fillRect( i*1, _h, 1, - ( 255 + data[i] ) / 255 * _h );
            }
            _ctx5.fill();

            //符号なし8bitArrayを生成
            var data = new Float32Array( analyser.frequencyBinCount );
            analyser.getFloatFrequencyData( data );
            var len = data.length;
            var _nums = 32;
            var _step = len / _nums;
            var _max = 0;
            var _alllist = [];
            for(var i = 0; i < _nums; ++i)
            {
            	//上部の描画
            	//_ctx6.fillRect( i*1, _h, 1, - ( 255 + data[i] ) / 255 * _h );
            	var sum = 0;
            	for( var j = i * _step; j < ( i + 1 )  * _step; j ++)
            	{
            		sum += data[j];
            	}
            	sum /= _step;
            	_alllist[i] = sum;

            	_max = _max>sum?sum:_max;

            }

			var _w = _canvas6.width;
			var _h = _canvas6.height;
			_ctx6.clearRect( 0, 0, _w, _h );
            _ctx6.beginPath();

            var len = _alllist.length;
            for( var i = 0; i < len; i++ )
            {
            	var _par = _alllist[i] / _max;
            	_ctx6.fillRect( i*10, 0, 9, _par * _h );
            }
            _ctx6.fill();

            //符号なし8bitArrayを生成
            var data = new Float32Array( analyser.frequencyBinCount );
            analyser.getFloatFrequencyData( data );
            var len = data.length;
            var _nums = 32;
            var _step = len / _nums;
            var _max = 0;
            var _alllist = [];
            for(var i = 0; i < _nums; ++i)
            {
            	//上部の描画
            	//_ctx6.fillRect( i*1, _h, 1, - ( 255 + data[i] ) / 255 * _h );
            	var sum = 0;
            	for( var j = i * _step; j < ( i + 1 )  * _step; j ++)
            	{
            		sum += data[j];
            	}
            	sum /= _step;
            	_alllist[i] = sum;

            	_max = _max>sum?sum:_max;
            }

			var _w = _canvas7.width;
			var _h = _canvas7.height;
			_ctx7.clearRect( 0, 0, _w, _h );
            _ctx7.beginPath();

            var _result = [];

            var len = _alllist.length;
            for( var i = 0; i < len; i++ )
            {
            	var _par = _alllist[i] / _max;
            	_result[i] = _par;
            	_ctx7.fillRect( i*10, _h * 0.5, 9, ( _salist[i] - _par ) * _h );
            }
            _ctx7.fill();
            _salist = _result;


		},1000/60);
	}

	var _salist = new Array(256)


})();
</script>
</body>
</html>

