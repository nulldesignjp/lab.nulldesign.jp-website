<!doctype html>
<html lang="ja-JP">
<head>
<title>webgl</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="keywords" content="URG sensor base.">
<meta name="description" content="">
<style>
html,body{height:100%;overflow:hidden;}
body{margin:0;padding:0;background-color:#000000;}
</style>
</head>
<body>
<div id="container"></div>
<script type="text/javascript" src="three.min.js"></script>
<script>
//	http://www.natural-science.or.jp/article/20130517211719.php
(function(){
	var renderer,scene,camera,focus,directionalLight,ambientLight,liquidPlane;
	var raycaster,mouse,focusPoint,isClick;

	var friction = 0.99;

	var N = 160;
	var l = 1.0;
	var dt = 0.1; //時間間隔
	var dd = 1.0; //空間間隔
	var v = 4;    //速度

	N = 96;
	l = 8.0;

	//境界条件の設定
	var BC = "Neumann"; //or "Dirichlet"
	var peakPosition = { x: 0, y: 0, z: 50, sigma2: N };
	var peakPosition_bound = { x_min: -50, x_max: 50, y_min: -50, y_max: 50, z_min: -50, z_max: 100, sigma2_min: 10, sigma2_max: 100 };

	//一時停止フラグ
	var restartFlag = false; //再計算フラグ
	var stopFlag = false;     //一時停止フラグ

	var Tn = 3;
	var f = new Array(Tn);

	//	start
	initialCondition(peakPosition);
		
	init();
	initObject();
	initRaycast();
	loop();


	//	-------------------------------------------------------------
	function initialCondition(parameter)
	{
		var x0 = parameter.x;
		var y0 = parameter.y;
		var z0 = parameter.z;
		var sigma2 = parameter.sigma2;
		for (var t = 0; t < Tn; t++) {
			f[t] = new Array(N);
			for (i = 0; i <= N; i++) {
				f[t][i] = new Array(N);
				for (j = 0; j <= N; j++) {
					var x = (-N / 2 + i) * l;
					var y = (-N / 2 + j) * l;
					//初期条件を与える
					var z = z0 * Math.exp(-(Math.pow(x-x0, 2) + Math.pow(y-y0, 2)) / (2*sigma2));
					f[0][i][j] = z;
				}
			}
		}
		for (var i = 1; i <= N - 1; i++) {
			for (var j = 1; j <= N - 1; j++) {
				f[1][i][j] = f[0][i][j] + v * v / 2.0 * dt * dt / (dd * dd) * (f[0][i + 1][j] + f[0][i - 1][j] + f[0][i][j + 1] + f[0][i][j - 1] - 4.0 * f[0][i][j]);
			}
		}
		if (BC == "Dirichlet") {
			//ディリクレ境界条件
			for (var i = 0; i <= N; i++) {
				f[1][i][0] = f[1][i][N] = f[1][0][i] = f[1][N][i] = 0.0; //境界条件
			}
		} else if (BC == "Neumann") {
			//ノイマン境界条件
			for (var i = 1; i <= N-1; i++) {
				f[1][i][0] = f[1][i][1];
				f[1][i][N] = f[1][i][N - 1];
				f[1][0][i] = f[1][1][i];
				f[1][N][i] = f[1][N - 1][i];
			}
			//角の処理
			f[1][0][0] = (f[1][0][1] + f[1][1][0]) / 2;
			f[1][0][N] = (f[1][0][N-1] + f[1][1][N]) / 2;
			f[1][N][0] = (f[1][N-1][0] + f[1][N][1]) / 2;
			f[1][N][N] = (f[1][N-1][N] + f[1][N][N-1]) / 2;
		}
	}

	function init() {
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setClearColor(0xFFFFFF);
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.getElementById('container').appendChild(renderer.domElement);

		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0xFFFFFF, 600, 800 );

		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
		camera.position.set(0, 0, 200);
		camera.position.set(0, -400, 400);

		focus = new THREE.Vector3(0,0,0);
		camera.lookAt(focus);

		directionalLight = new THREE.DirectionalLight(0xDDDDDD, 1.0, 0);
		directionalLight.position.set(30, 30, 100);

		ambientLight = new THREE.AmbientLight(0x181818);
		scene.add(ambientLight);
		scene.add(directionalLight);
	}

	function initObject()
	{
		initialCondition( peakPosition );

		var geometry = new THREE.PlaneGeometry(N*l,N*l,N,N);
		geometry.computeFaceNormals();
		geometry.computeVertexNormals();

		//var material = new THREE.MeshLambertMaterial();
		var material = new THREE.MeshPhongMaterial({ color: 0xFFFFFF,shading: THREE.SmoothShading, metal:true, specular: 0xFFFFFF, shininess: 240 });
		//	, emissive: 0x000000
		liquidPlane = new THREE.Mesh(geometry, material);

		scene.add(liquidPlane);
	}

	//	Raycast
	function initRaycast()
	{
		raycaster = new THREE.Raycaster();
		mouse = {x:0,y:0};
		focusPoint = null;
		isClick = false;
		window.addEventListener( 'mousedown', onDocumentMouseDown );
		window.addEventListener( 'mouseup', onDocumentMouseUp );
		window.addEventListener( 'mousemove', onDocumentMouseMove );
	}

	//グローバル変数の宣言
	var step = 0; //ステップ数
	function loop() {

		//時刻の取得
		var time = step * dt;
		//時間発展
		if (stopFlag == false) {
			//ステップ数のインクリメント
			step++;
			time = step * dt;
			for (var i = 1; i <= N - 1; i++) {
				for (var j = 1; j <= N - 1; j++) {
					f[2][i][j] = 2.0 * f[1][i][j] - f[0][i][j] + v * v * dt * dt / (dd * dd) * (f[1][i + 1][j] + f[1][i - 1][j] + f[1][i][j + 1] + f[1][i][j - 1] - 4.0 * f[1][i][j]);
				}
			}
			if (BC == "Dirichlet") {
				//ディリクレ境界条件
				for (var i = 0; i <= N; i++) {
					f[2][i][0] = f[2][i][N] = f[2][0][i] = f[2][N][i] = 0.0;    //境界条件
				}
			} else if (BC == "Neumann") {
				//ノイマン境界条件
				for (var i = 1; i <= N-1; i++) {
					f[2][i][0] = f[2][i][1];
					f[2][i][N] = f[2][i][N - 1];
					f[2][0][i] = f[2][1][i];
					f[2][N][i] = f[2][N - 1][i];
				}
				//角の処理
				f[2][0][0] = (f[2][0][1] + f[2][1][0]) / 2;
				f[2][0][N] = (f[2][0][N - 1] + f[2][1][N]) / 2;
				f[2][N][0] = (f[2][N - 1][0] + f[2][N][1]) / 2;
				f[2][N][N] = (f[2][N - 1][N] + f[2][N][N - 1]) / 2;

			}
			//次の計算のために配列の数値を入れかえる。ここで過去の情報は失われる。
			for (var i = 0; i <= N; i++) {
				for (var j = 0; j <= N; j++) {
					f[0][i][j] = f[1][i][j];
					f[1][i][j] = f[2][i][j];

					//	add
					f[1][i][j] *= friction;
				}
			}
		}

		//	DRAW
		var a =0;
		for (i = 0; i <= N; i++) {
			for (j = 0; j <= N; j++) {
				var x = (-N / 2 + i) * l;
				var y = (-N / 2 + j) * l;
				var z = f[1][i][j];
				liquidPlane.geometry.vertices[a].z = z;
				a++;
			}
		}

		liquidPlane.geometry.normalsNeedUpdate = true;
		liquidPlane.geometry.verticesNeedUpdate = true;
		//面の法線ベクトルを計算
		liquidPlane.geometry.computeFaceNormals();
		//面の法線ベクトルから頂点法線ベクトルの計算
		liquidPlane.geometry.computeVertexNormals();

		camera.lookAt(focus);
		renderer.render( scene, camera );

		requestAnimationFrame(loop);
	}

	function onDocumentMouseDown(e)
	{
		isClick = true;
		mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
		e.preventDefault();

		addFieldPower(16);
	}

	function onDocumentMouseUp(e)
	{
		isClick = false;
		e.preventDefault();
	}

	function onDocumentMouseMove(e)
	{
		if( isClick )
		{
			mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
			addFieldPower(4);
		}
		e.preventDefault();
	}

	function addFieldPower( _power )
	{
		_power = _power==undefined?1:_power;

		raycaster.setFromCamera( mouse, camera );
		var intersections = raycaster.intersectObjects( [liquidPlane] );
		var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;


		if( intersection !== null )
		{
			focusPoint = intersection.point;

			var _x = N - Math.floor( focusPoint.y + N * 0.5 );
			var _y = Math.floor( focusPoint.x + N * 0.5 );

			//
			var parameter = { x: _x, y: _y, z: _power, sigma2: 50 };

			parameter.x -= N * 0.5;
			parameter.y -= N * 0.5;

			var x0 = parameter.x;
			var y0 = parameter.y;
			var z0 = parameter.z;
			var sigma2 = parameter.sigma2;

			for (i = 0; i <= N; i++) {
				for (j = 0; j <= N; j++) {
					var x = (-N / 2 + i) * l;
					var y = (-N / 2 + j) * l;
					//初期条件を与える
					var z = z0 * Math.exp(-(Math.pow(x-x0, 2) + Math.pow(y-y0, 2)) / (2*sigma2));
					f[0][i][j] += z;
				}
			}
		}
	}
	window.onresize = function()
	{
		var width  = window.innerWidth;
		var height = window.innerHeight;
		renderer.setSize( width, height );
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
	}
})();
</script>
</body>
</html>