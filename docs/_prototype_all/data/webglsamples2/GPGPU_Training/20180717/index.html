<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="Content-Language" content="ja">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="imagetoolbar" content="no">
<meta http-equiv="cleartype" content="on">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes, viewport-fit=cover">
<meta name="keywords" content="">
<meta name="description" content="">
<link href="http://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet" type="text/css">
<link href="shared/css/reset.css" rel="stylesheet" type="text/css" media="all">
<link href="shared/css/style.css" rel="stylesheet" type="text/css" media="all">
<title>GLSL Shader</title>
</head>
<body>
<div id="container">
<div id="siteHead">
<h1>GLSL Shader</h1>
<h2>NOISE</h2>
<!--/ siteHead --></div>
<div id="siteBody">
<div id="webglView"><!--/ webglView --></div>
<!--/ siteBody --></div>
<div id="siteFoot"><p>&copy; nulldesign.jp</p>
<!--/ siteFoot --></div>
<!--/ container --></div>
<script type="x-shader/x-vertex" id="vertexshader">
void main()
{
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float random (in float x) {
    return fract(sin(x)*1e4);
}

float random (in vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

float pattern(vec2 st, vec2 v, float t) {
    vec2 p = floor(st+v);
    return step(t, random(100.+p*.000001)+random(p.x)*0.5 );
}

void main() {
    vec2 uv = gl_FragCoord.xy/resolution.xy;
    uv.x *= resolution.x/resolution.y;

    vec2 grid = vec2(100.0,150.);
    uv *= grid;

    vec2 ipos = floor(uv);  // integer
    vec2 fpos = fract(uv);  // fraction

    vec2 vel = vec2(time*2.*max(grid.x,grid.y)); // time
    vel *= vec2(-1.,0.0) * random(1.0+ipos.y); // direction

    // Assign a random value base on the integer coord
    vec2 offset = vec2(0.1,0.) * 10.0;

    vec3 color = vec3(0.);
    color.r = pattern(uv+offset,vel,0.5+mouse.x/resolution.x);
    color.g = pattern(uv,vel,0.5+mouse.x/resolution.x);
    color.b = pattern(uv-offset,vel,0.5+mouse.x/resolution.x);

    // Margins
    color *= step(0.2,fpos.y);

    gl_FragColor = vec4(1.0-color,1.0);
}
</script>
<script type="text/javascript" src="shared/js/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="shared/js/three.min.js"></script>
<script type="text/javascript" src="shared/js/OrbitControls.js"></script>
<script type="text/javascript" src="shared/js/world.js"></script>
<script type="text/javascript" src="shared/js/capture.js"></script>
<!-- <script type="text/javascript" src="shared/js/engine.js"></script> -->
<script type="text/javascript">
window.onload = function(){

  var _world,_plane;

  init();
  start();

  function init(){
    _world = new world('webglView');
    _plane = createPlane();
    _world.add( _plane );
    _world.controls.autoRotate = false;
    _world.controls.enabled = false;

    _plane.scale.x = window.innerWidth;
    _plane.scale.y = window.innerHeight;


    window.addEventListener( 'resize', function(){
      _plane.scale.x = window.innerWidth;
      _plane.scale.y = window.innerHeight;

      _plane.material.uniforms.resolution.value.x = window.innerWidth;
      _plane.material.uniforms.resolution.value.y = window.innerHeight;
    })

    window.addEventListener( 'mousemove', function( e ){
      _plane.material.uniforms.mouse.value.x = e.pageX / window.innerWidth;
      _plane.material.uniforms.mouse.value.y = ( window.innerHeight - e.pageY ) / window.innerHeight;
      e.preventDefault();
    });

    window.addEventListener( 'touchmove', function( e ){
      _plane.material.uniforms.mouse.value.x = e.touches[0].pageX / window.innerWidth;
      _plane.material.uniforms.mouse.value.y = ( window.innerHeight - e.touches[0].pageY ) / window.innerHeight;
      e.preventDefault();
    });





    var _cap = new capture( $('#webglView canvas')[0]);
    window.addEventListener( 'keydown', function( e ){
      if( e.keyCode == 32 )
      {
        _cap.shoot();
      }
    });

  }

  function start(){
    loop( 0 );
  }

  function loop( _stepTime ){
    window.requestAnimationFrame( loop );
    _plane.material.uniforms.time.value = _stepTime * 0.001;
    _plane.material.uniforms.buckbuffer.value = _world.renderTarget.texture;
  }

  function createPlane(){
      var _uniforms = {
        'time': {value:0},
        'mouse': {value: new THREE.Vector2()  },
        'resolution': {value: new THREE.Vector2( window.innerWidth, window.innerHeight )  },
        'buckbuffer': {value: _world.renderTarget.texture}
      };

      var _material = new THREE.ShaderMaterial({
        uniforms: _uniforms,
        vertexShader:   document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
        transparent: true
      });

      var _geometry = new THREE.PlaneGeometry(1,1,1,1);

      return new THREE.Mesh(_geometry,_material);
  }
}
</script>
</body>
</html>
